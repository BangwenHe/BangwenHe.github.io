

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="https://avatars.githubusercontent.com/u/32662175">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="何榜文">
  <meta name="keywords" content="">
  
    <meta name="description" content="Containers条款 1 仔细选择你的容器 vector是一种可以默认使用的序列类型，当很频繁地对序列中部进行插入和删除时应该用list，当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构   连续内存容器（也叫做基于数组的容器）在一个或多个（动态分配）的内存块中保存它们的元素。如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective STL - 01 - Containers">
<meta property="og:url" content="http://hebangwen.github.io/2024/03/17/Containers/index.html">
<meta property="og:site_name" content="Yet Another 何榜文&#39;s Blog">
<meta property="og:description" content="Containers条款 1 仔细选择你的容器 vector是一种可以默认使用的序列类型，当很频繁地对序列中部进行插入和删除时应该用list，当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构   连续内存容器（也叫做基于数组的容器）在一个或多个（动态分配）的内存块中保存它们的元素。如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-17T12:01:48.000Z">
<meta property="article:modified_time" content="2024-10-29T14:38:44.793Z">
<meta property="article:author" content="何榜文">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="Effective STL">
<meta property="article:tag" content="Containers">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Effective STL - 01 - Containers - Yet Another 何榜文&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"hebangwen.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yet Another 何榜文&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/todolist/" target="_self">
                <i class="iconfont icon-plan"></i>
                <span>待办事项</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>联系我</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Effective STL - 01 - Containers"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-17 20:01" pubdate>
          2024年3月17日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          41 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Effective STL - 01 - Containers</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><h2 id="条款-1-仔细选择你的容器"><a href="#条款-1-仔细选择你的容器" class="headerlink" title="条款 1 仔细选择你的容器"></a>条款 1 仔细选择你的容器</h2><blockquote>
<p>vector是一种可以默认使用的序列类型，当很频繁地对序列中部进行插入和删除时应该用list，当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构</p>
</blockquote>
<blockquote>
<p>连续内存容器（也叫做基于数组的容器）在一个或多个（动态分配）的内存块中保存它们的元素。<strong>如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间</strong>。这种移动影响了效率（参见条款5和14）和异常安全（就像我们将会看到的）。标准的连续内存容器是vector、string和deque。</p>
</blockquote>
<blockquote>
<p><strong>基于节点的容器在每个内存块（动态分配）中只保存一个元素</strong>。容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。</p>
</blockquote>
<blockquote>
<p>你要把迭代器、指针和引用的失效次数减到最少吗？如果是，你就应该使用基于节点的容器，因为在这些容器上进行插入和删除不会使迭代器、指针和引用失效（除非它们指向你删除的元素）。<strong>一般来说，在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效</strong>。</p>
</blockquote>
<blockquote>
<p>你需要具有有以下特性的序列容器吗：1）可以使用随机访问迭代器；2）只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？这个一个非常特殊的情况，但如果你遇到这种情况，deque就是你梦想的容器。（有趣的是，当插入只在容器结尾时，deque的迭代器也可能会失效，deque是唯一一个“在迭代器失效时不会使它的指针和引用失效”的标准STL容器。）</p>
</blockquote>
<p>在 vector 上会插入和删除会导致当前的迭代器失效。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; *it &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br><br>v.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">-1</span>);<br>cout &lt;&lt; *it &lt;&lt; endl;  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<p>TODO：对应容器的失效规则。</p>
<h2 id="条款2：小心对“容器无关代码”的幻想"><a href="#条款2：小心对“容器无关代码”的幻想" class="headerlink" title="条款2：小心对“容器无关代码”的幻想"></a>条款2：小心对“容器无关代码”的幻想</h2><blockquote>
<p>标准的内存相邻容器（参见条款1）都提供随机访问迭代器，标准的基于节点的容器（再参见条款1）都提供双向迭代器。序列容器支持push_front或push_back，但关联容器不支持。关联容器提供对数时间复杂度的lower_bound、upper_bound和equal_range成员函数，但序列容器却没有。</p>
</blockquote>
<blockquote>
<p>在一个序列容器上用一个迭代器作为参数调用erase，会返回一个新迭代器，但在关联容器上什么都不返回。</p>
</blockquote>
<p>既然有了要一次次的改变容器类型的必然性，你可以用这个常用的方法让改变得以简化：使用封装，封装，再封装。其中一种最简单的方法是通过自由地对容器和迭代器类型使用typedef。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;...&#125;;<br>vector&lt;Widget&gt; vw;<br>Widget bestWidget;<br>... <span class="hljs-comment">// 给bestWidget一个值</span><br>vector&lt;Widget&gt;::iterator i = <span class="hljs-comment">// 寻找和bestWidget相等的Widget</span><br> <span class="hljs-built_in">find</span>(vw.<span class="hljs-built_in">begin</span>(), vw.<span class="hljs-built_in">end</span>(), bestWidget);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; ... &#125;;<br><span class="hljs-keyword">typedef</span> vector&lt;Widget&gt; WidgetContainer;<br><span class="hljs-keyword">typedef</span> WidgetContainer::iterator WCIterator;<br>WidgetContainer cw;<br>Widget bestWidget;<br>...<br>WCIterator i = <span class="hljs-built_in">find</span>(cw.<span class="hljs-built_in">begin</span>(), cw.<span class="hljs-built_in">end</span>(), bestWidget);<br></code></pre></td></tr></table></figure>

<p>如果你不想暴露出用户对你所决定使用的容器的类型，你需要更大的火力，那就是class。</p>
<p>目前有了 auto 操作，大部分 typedef 应该是可以省略的。</p>
<h2 id="条款3：使容器里对象的拷贝操作轻量而正确"><a href="#条款3：使容器里对象的拷贝操作轻量而正确" class="headerlink" title="条款3：使容器里对象的拷贝操作轻量而正确"></a>条款3：使容器里对象的拷贝操作轻量而正确</h2><p>一旦一个对象进入一个容器，以后对它的拷贝并不少见。如果你从vector、string或deque中<strong>插入或删除</strong>了什么，现有的容器元素会移动（拷贝）（参见条款5和14）。如果你使用了任何<strong>排序算法</strong>（参见条款31）：next_permutation或者previous_permutation；remove、unique或它们的同类（参见条款32）；rotate或reverse等，对象会移动（拷贝）。是的，拷贝对象是STL的方式。</p>
<blockquote>
<p>一个使拷贝更高效、正确而且对分割问题免疫的简单的方式是<strong>建立指针的容器</strong>而不是对象的容器。</p>
<p><em>所以，对于 容器 来说，大部分都只是保存一个 <code>T*</code> ，而不是数组</em></p>
</blockquote>
<p>和数组对比，STL容器更文明。它们只建立（通过拷贝）你需要的个数的对象，而且它们只在你指定的时候做。是的，我们需要知道STL容器使用了拷贝，但是别忘了一个事实：比起数组它们仍然是一个进步。</p>
<h2 id="条款4：用empty来代替检查size-是否为0"><a href="#条款4：用empty来代替检查size-是否为0" class="headerlink" title="条款4：用empty来代替检查size()是否为0"></a>条款4：用empty来代替检查size()是否为0</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; list1; <br>list&lt;<span class="hljs-type">int</span>&gt; list2; <br>... <br>list1.<span class="hljs-built_in">splice</span>( <span class="hljs-comment">// 把list2中</span><br> list1.<span class="hljs-built_in">end</span>(), list2, <span class="hljs-comment">// 从第一次出现5到</span><br> <span class="hljs-built_in">find</span>(list2.<span class="hljs-built_in">begin</span>(), list2.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>), <span class="hljs-comment">// 最后一次出现10</span><br> <span class="hljs-built_in">find</span>(list2.<span class="hljs-built_in">rbegin</span>(), list2.<span class="hljs-built_in">rend</span>(), <span class="hljs-number">10</span>).<span class="hljs-built_in">base</span>() <span class="hljs-comment">// 的所有节点移到list1的结尾。</span><br>); <span class="hljs-comment">// 关于调用的</span><br> <span class="hljs-comment">// &quot;base()&quot;的信息，请参见条款28</span><br></code></pre></td></tr></table></figure>

<p>考虑这部分代码。（其中 splice 是拼接，接合，即把两个 list 合并。上述代码的意思是：在 list1 的末尾，拷贝从 list2 第一次出现 5，到最后一次出现 10 的所有数据）</p>
<p>常数时间的 splice 与常数时间的 size 是相违背的，即：</p>
<ol>
<li>如果 splice 是常数时间，那么无法在 splice 的过程中更新 size，那么每次调用 size 时就必须以 O(N) 的方式遍历</li>
<li>如果 size 是常数时间，那么 splice 必须更新 size，splice 就会是 O(N)</li>
</ol>
<p>因此，调用 <code>empty()</code> 可以获得更好的时间复杂度，因为它总是 O(1) 的</p>
<h2 id="条款5：尽量使用区间成员函数代替它们的单元素兄弟"><a href="#条款5：尽量使用区间成员函数代替它们的单元素兄弟" class="headerlink" title="条款5：尽量使用区间成员函数代替它们的单元素兄弟"></a>条款5：尽量使用区间成员函数代替它们的单元素兄弟</h2><p>区间成员函数指的是使用 range 的成员函数，使用一个开头迭代器，一个结尾迭代器标识区间。然后根据不同的操作，有不同的变化。单元素兄弟，就是直接访问数据。</p>
<p>区间成员函数 和 单元素兄弟 写法的对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v1, v2;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 单元素写法</span><br>v1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; it != v2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>  v1.<span class="hljs-built_in">push_back</span>(*it);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">insertLoc</span><span class="hljs-params">(v1.begin())</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br> insertLoc = v1.<span class="hljs-built_in">insert</span>(insertLoc, data[i]);<br> ++insertLoc;  <span class="hljs-comment">// 迭代器失效, 必须更新</span><br>&#125;<br><br><span class="hljs-comment">// 区间成员函数写法</span><br>v1.<span class="hljs-built_in">assgin</span>(v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>());<br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">copy</span>(v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(v1. v1.<span class="hljs-built_in">end</span>()));<br><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), data, data + numValues);<br></code></pre></td></tr></table></figure>

<p>copy 仍然比写 assign 的调用要做更多的工作。此外，虽然在这段代码中没有表现出循环，在copy中的确存在一个循环(参见条款43）。结果，效率损失仍然存在。我也会在下面讨论。在这里，我要离题一下来指出几乎所有目标区间是通过插入迭代器（比如，通过inserter，back_inserter或front_inserter）指定的copy的使用都可以——应该——通过调用区间成员函数来代替。</p>
<p>本条款的主题：<strong>几乎所有目标区间被插入迭代器指定的copy的使用都可以用调用的区间成员函数的来代替</strong>。</p>
<p>原因：1、减少函数调用；2、数据移动的开销（单元素每次都要移动一次数组，区间可以直接移动到最终位置，<strong>减少了 N - 1 次的 移动&#x2F;拷贝 开销</strong>）；3、vector 扩容机制。</p>
<p>支持区间成员函数的写法：</p>
<ul>
<li>构造函数：<code>Container::Container(InputIterator begin, OutputIterator end);</code></li>
<li>插入：<ul>
<li>序列容器需要指定插入位置： <code>void Container::insert(iterator position, InputIterator begin, InputIterator end);</code></li>
<li>关联容器由于是通过比较元素的大小来决定插入位置的，所以不需要插入位置： <code>void Container::insert(InputIterator begin, InputIterator end);</code></li>
</ul>
</li>
<li>删除：<ul>
<li>序列容器由于迭代器失效，因此会返回一个迭代器： <code>iterator Container::erase(iterator begin, iterator end);</code></li>
<li>关联容器不会返回（是因为返回会导致不必要的性能开销？）：  <code>void Container::erase(iterator begin, iterator end);</code></li>
</ul>
</li>
<li>赋值：<ul>
<li><code>void Container::assign(InputIterator begin, InputIterator end);</code></li>
</ul>
</li>
</ul>
<h2 id="条款6：警惕C-最令人恼怒的解析"><a href="#条款6：警惕C-最令人恼怒的解析" class="headerlink" title="条款6：警惕C++最令人恼怒的解析"></a>条款6：警惕C++最令人恼怒的解析</h2><p>C++ 中会首先解析函数，因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 被解析为一个函数</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lFunc</span><span class="hljs-params">(istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss), istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br><br><span class="hljs-comment">// 被成功解析</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">((istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss)), istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br>for_each(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>第一个变量的定义被解析为一个单纯的函数声明，但是第二个定义被解析为变量定义。（通过添加一个括号的形式，但是这样可能导致 <em>未来的编译器</em> 报错）</p>
<p>还有另一种不使用匿名对象的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dataBegin</span><span class="hljs-params">(iss)</span>, <span class="hljs-title">dataEnd</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(dataBegin, dataEnd)</span></span>;<br></code></pre></td></tr></table></figure>

<p>缺点就是不够符合 C++ STL 的风格。</p>
<h2 id="条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针"><a href="#条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针" class="headerlink" title="条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针"></a>条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针</h2><p>当一个指针的容器被销毁时，会销毁它（那个容器）包含的每个元素，但指针的“析构函数”是无操作！它肯定不会调用delete。即，<strong>只回收了指针占用的内存，而没有回收指针指向的内容占用的内存</strong>。因此，对于  指针的容器，我们需要手动 delete 回收。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSth</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>*&gt; vi;<br>    vi.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10&#x27;000&#x27;000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10&#x27;000&#x27;000</span>; i++)  vi.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">12</span>&#125;);<br>    <span class="hljs-comment">// 回收内存之后, 没有内存泄漏</span><br>    for_each(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>*&amp; a) &#123; <span class="hljs-keyword">delete</span> a; &#125;);  <br>&#125;<br><br><span class="hljs-comment">// 使用智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSthSmart</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vui;<br>    vui.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10&#x27;000&#x27;000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10&#x27;000&#x27;000</span>; i++)  vui.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">12</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">doSth</span>();            <span class="hljs-comment">// 内存泄漏 6129 MB</span><br>        <span class="hljs-comment">// doSthSmart();    // 无泄漏 4.2 MB</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面还使用仿函数，构建了一个自动回收内存的仿函数类。</p>
<h2 id="条款8：永不建立auto-ptr的容器"><a href="#条款8：永不建立auto-ptr的容器" class="headerlink" title="条款8：永不建立auto_ptr的容器"></a>条款8：永不建立auto_ptr的容器</h2><p>auto_ptr 不可移植，并且  <strong>对 auto_ptr 的拷贝会改变它本身的值</strong>。</p>
<h2 id="条款9：在删除选项中仔细选择"><a href="#条款9：在删除选项中仔细选择" class="headerlink" title="条款9：在删除选项中仔细选择"></a>条款9：在删除选项中仔细选择</h2><p>如何选择一个合适的删除选项？分情况讨论如下：</p>
<ul>
<li>去除一个容器中有特定值的所有对象：<ul>
<li>如果容器是vector、string或deque，使用erase-remove惯用法</li>
<li>如果容器是list，使用list::remove</li>
<li>如果容器是标准关联容器，使用它的erase成员函数。</li>
</ul>
</li>
<li>去除一个容器中满足一个特定判定式的所有对象：<ul>
<li>如果容器是vector、string或deque，使用erase-remove_if惯用法。</li>
<li>如果容器是list，使用list::remove_if。</li>
<li>如果容器是标准关联容器，使用remove_copy_if和swap，或写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</li>
</ul>
</li>
<li>在循环内做某些事情（除了删除对象之外）：<ul>
<li>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。</li>
<li>如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 必须加上这部分 `class...`</span><br><span class="hljs-comment">// 因为 vector 的实际签名是 vector&lt;T, _Allocator&lt;T&gt;&gt;</span><br><span class="hljs-comment">// 不能只加入一个 template parameter</span><br><span class="hljs-comment">// 由于 cout 中似乎无法添加 constant</span><br><span class="hljs-comment">// 因此必须自己建一个类, 来让 C++ 完成类型推导</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>...&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>, <span class="hljs-keyword">typename</span>... T&gt;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, Container&lt;T...&gt;&amp; c) &#123;<br>    <span class="hljs-keyword">using</span> ValueType = <span class="hljs-keyword">typename</span> Container&lt;T...&gt;::value_type;<br>    for_each(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), [&amp;os] (<span class="hljs-type">const</span> ValueType&amp; t) &#123;<br>        os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    list&lt;<span class="hljs-type">int</span>&gt; l&#123;v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()&#125;;<br>    set&lt;<span class="hljs-type">int</span>&gt; s&#123;v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()&#125;;<br><br>    <span class="hljs-comment">// 删除某一个数值</span><br>    <span class="hljs-comment">// vector 使用 erase-remove 技术</span><br>    <span class="hljs-type">int</span> toBeRemoved = <span class="hljs-number">1</span>;<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), toBeRemoved), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// list 使用 remove</span><br>    l.<span class="hljs-built_in">remove</span>(toBeRemoved);<br><br>    <span class="hljs-comment">// set 使用 erase</span><br>    s.<span class="hljs-built_in">erase</span>(toBeRemoved);<br><br>    <span class="hljs-comment">// ===============</span><br>    <span class="hljs-comment">// 条件删除</span><br><br>    <span class="hljs-comment">// vector 使用 erase-remove_if 技术</span><br>    <span class="hljs-type">int</span> upperBound = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">auto</span> pred = [&amp;] (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a) &#123; <span class="hljs-keyword">return</span> a &lt;= upperBound; &#125;;<br><br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), pred), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// list 使用 remove_if</span><br>    l.<span class="hljs-built_in">remove_if</span>(pred);<br><br>    <span class="hljs-comment">// set 使用 remove_copy_if-swap 技术</span><br>    set&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-comment">// 可以使用 inserter(tmp, tmp.end())</span><br>    <span class="hljs-comment">// 不能使用 back_inserter(tmp), 它会调用 push_back 方法</span><br>    <span class="hljs-comment">// 导致 set 容器报错</span><br>    <span class="hljs-comment">// 这里报错很奇怪, 报错的地方在 `set&lt;in&gt;s` 中, 而不是调用的地方</span><br>    <span class="hljs-built_in">remove_copy_if</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(tmp, tmp.<span class="hljs-built_in">end</span>()), pred);<br>    s.<span class="hljs-built_in">swap</span>(tmp);<br><br>    <span class="hljs-comment">// ===============</span><br>    <span class="hljs-comment">// 删除的过程中执行操作</span><br><br>    <span class="hljs-comment">// 序列容器  ---  需要更新 迭代器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>();) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pred</span>(*it)) &#123;<br>            <span class="hljs-comment">// 此时已经更新了 迭代器, 因此不需要 ++</span><br>            it = v.<span class="hljs-built_in">erase</span>(it);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对于不满足条件的值, 直接 ++</span><br>            it++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// set 使用 for 循环  ---  需要及时更新 迭代器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ) &#123;<br>        <span class="hljs-comment">// 对于所有非法的值, 删除之后再移动迭代器到下一个位置</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pred</span>(*it))  s.<span class="hljs-built_in">erase</span>(it++);<br>        <span class="hljs-comment">// 合法的值, 直接移动即可</span><br>        <span class="hljs-keyword">else</span>  it++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="条款10：注意分配器的协定和约束"><a href="#条款10：注意分配器的协定和约束" class="headerlink" title="条款10：注意分配器的协定和约束"></a>条款10：注意分配器的协定和约束</h2><p>因此，如果你想要写自定义分配器，让我们总结你需要记得的事情。</p>
<ul>
<li>把你的分配器做成一个模板，带有模板参数T，代表你要分配内存的对象类型。</li>
<li>提供pointer和reference的typedef，但是总是让pointer是T*，reference是T&amp;。</li>
<li>决不要给你的分配器添加对象状态。通常，分配器不能有非静态的数据成员。</li>
<li>记得应该传给分配器的<strong>allocate成员函数需要分配的对象个数而不是字节数</strong>。也应该记得<strong>这些函数返回T*指针（通过pointer typedef），即使还没有T对象被构造</strong>。</li>
<li>一定要提供标准容器依赖的内嵌rebind模板。</li>
</ul>
<p>为什么不能添加对象状态？因为编译器认为两个相同的类型的分配器，总是相同的。因此分配器只能拥有静态成员。</p>
<p>为什么需要 rebind？因为对于基于节点的容器（如 list、set、map 等），他们需要的数据结构是 <code>Node&lt;T&gt;</code> ，而不是 <code>T</code> 。为了分配节点的内存，因此提出了 rebind。通过 rebind 分配这部分的节点内存，rebind 的签名也变成了 <code>allocator&lt;T&gt;::rebind&lt;Node&lt;T&gt;&gt;::other</code> ，其中的 other 就是 <code>&lt;Node&lt;T&gt;</code> 。</p>
<p>MSVC 的 allocator 实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_INLINE_VAR <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> _Asan_granularity = <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">static_assert</span>(!is_const_v&lt;_Ty&gt;, <span class="hljs-string">&quot;The C++ Standard forbids containers of const elements &quot;</span><br>                                    <span class="hljs-string">&quot;because allocator&lt;const T&gt; is ill-formed.&quot;</span>);<br><br>    <span class="hljs-keyword">using</span> _From_primary = allocator;<br><br>    <span class="hljs-keyword">using</span> value_type = _Ty;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    <span class="hljs-keyword">using</span> pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty*;<br>    <span class="hljs-keyword">using</span> const_pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = <span class="hljs-type">const</span> _Ty*;<br><br>    <span class="hljs-keyword">using</span> reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty&amp;;<br>    <span class="hljs-keyword">using</span> const_reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = <span class="hljs-type">const</span> _Ty&amp;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-keyword">using</span> size_type       = <span class="hljs-type">size_t</span>;<br>    <span class="hljs-keyword">using</span> difference_type = <span class="hljs-type">ptrdiff_t</span>;<br><br>    <span class="hljs-keyword">using</span> propagate_on_container_move_assignment           = true_type;<br>    <span class="hljs-keyword">using</span> is_always_equal _CXX20_DEPRECATE_IS_ALWAYS_EQUAL = true_type;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    <span class="hljs-comment">// rebind 的实现</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Other</span>&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS</span> rebind &#123;<br>        <span class="hljs-keyword">using</span> other = allocator&lt;_Other&gt;;<br>    &#125;;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD _Ty* <span class="hljs-title">address</span><span class="hljs-params">(_Ty&amp; _Val)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _STD <span class="hljs-built_in">addressof</span>(_Val);<br>    &#125;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD <span class="hljs-type">const</span> _Ty* <span class="hljs-title">address</span><span class="hljs-params">(<span class="hljs-type">const</span> _Ty&amp; _Val)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _STD <span class="hljs-built_in">addressof</span>(_Val);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 分配内存 或者 rebind 的内存</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">(<span class="hljs-type">const</span> allocator&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>= <span class="hljs-keyword">default</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Other</span>&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">(<span class="hljs-type">const</span> allocator&lt;_Other&gt;&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br>    _CONSTEXPR20 ~<span class="hljs-built_in">allocator</span>()                           = <span class="hljs-keyword">default</span>;<br>    _CONSTEXPR20 allocator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> allocator&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">_CONSTEXPR20 <span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(_Ty* <span class="hljs-type">const</span> _Ptr, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        _STL_ASSERT(_Ptr != <span class="hljs-literal">nullptr</span> || _Count == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;null pointer cannot point to a block of non-zero size&quot;</span>);<br>        <span class="hljs-comment">// no overflow check on the following multiply; we assume _Allocate did that check</span><br>        _Deallocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Ptr, <span class="hljs-built_in">sizeof</span>(_Ty) * _Count);<br>    &#125;<br><br>    _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) <span class="hljs-function">_Ty* <span class="hljs-title">allocate</span><span class="hljs-params">(_CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(value_type) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;value_type must be complete before calling allocate.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty*&gt;(_Allocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Get_size_of_n&lt;<span class="hljs-built_in">sizeof</span>(_Ty)&gt;(_Count)));<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_CXX23</span><br>    <span class="hljs-function">_NODISCARD_RAW_PTR_ALLOC <span class="hljs-keyword">constexpr</span> allocation_result&lt;_Ty*&gt; <span class="hljs-title">allocate_at_least</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">allocate</span>(_Count), _Count&#125;;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_CXX23</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) <span class="hljs-function">_Ty* <span class="hljs-title">allocate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">allocate</span>(_Count);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Objty</span>, <span class="hljs-keyword">class</span>... _Types&gt;<br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS <span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(_Objty* <span class="hljs-type">const</span> _Ptr, _Types&amp;&amp;... _Args)</span> </span>&#123;<br>        ::<span class="hljs-keyword">new</span> (_Voidify_iter(_Ptr)) _Objty(_STD forward&lt;_Types&gt;(_Args)...);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Uty</span>&gt;<br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(_Uty* <span class="hljs-type">const</span> _Ptr)</span> </span>&#123;<br>        _Ptr-&gt;~_Uty();<br>    &#125;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD <span class="hljs-type">size_t</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">-1</span>) / <span class="hljs-built_in">sizeof</span>(_Ty);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> _Minimum_allocation_alignment = _Asan_granularity;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="条款11：理解自定义分配器的正确用法"><a href="#条款11：理解自定义分配器的正确用法" class="headerlink" title="条款11：理解自定义分配器的正确用法"></a>条款11：理解自定义分配器的正确用法</h2><p>自定义前提：</p>
<ul>
<li>你用了<strong>基准测试，性能剖析</strong>，而且实验了你的方法得到默认的STL内存管理器（即allocator <T>）在你的STL需求中太慢、浪费内存或造成过度的碎片的结论，并且你肯定你自己能做得比它好。</li>
<li>或者你发现allocator<T>对线程安全采取了措拖，但是你只对<strong>单线程的程序</strong>感兴趣，你不想花费你不需要的同步开销。</li>
<li>或者你知道在<strong>某些容器里的对象通常一同被使用</strong>，所以你想在一个特别的堆里把它们放得很近使引用的区域性最大化。（hint，提高局部性）</li>
<li>或者你想建立一个<strong>相当共享内存的唯一的堆</strong>，然后把一个或多个容器放在那块内存里，因为这样它们可以被其他进程共享。</li>
</ul>
<p>一个自定义 allocator 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">本文的例子是创建一个在  共享内存区  的对象, malloc 分配的内存在堆区</span><br><span class="hljs-comment">共享内存区 主要跟 多线程/多进程 有关, Linux 中由 SharedMemory 决定</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">makeShared</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeShared</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocator</span> &#123;<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> const_pointer = <span class="hljs-type">const</span> T*;<br>    <span class="hljs-keyword">using</span> reference = T&amp;;<br>    <span class="hljs-keyword">using</span> const_reference = <span class="hljs-type">const</span> T&amp;;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br>    <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br><br>    <span class="hljs-function">pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> numObjects, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *localityHint = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">makeShared</span>(numObjects * <span class="hljs-built_in">sizeof</span>(T));<br>        <span class="hljs-comment">// print message and allocate memory with global new</span><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;allocate &quot;</span> &lt;&lt; numObjects &lt;&lt; <span class="hljs-string">&quot; element(s)&quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot; of size &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T) <br>            &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;pointer&gt;(ptr);<br>    &#125;<br><br>    <span class="hljs-comment">// initialize elements of allocated storage p with value value</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span> <span class="hljs-params">(pointer p, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-comment">// initialize memory with placement new</span><br>        <span class="hljs-keyword">new</span>((<span class="hljs-type">void</span>*)p)<span class="hljs-built_in">T</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// destroy elements of initialized storage p</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span> <span class="hljs-params">(pointer p)</span> </span>&#123;<br>        <span class="hljs-comment">// destroy objects by calling their destructor</span><br>        p-&gt;~<span class="hljs-built_in">T</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(pointer dataPtr, <span class="hljs-type">size_t</span> numObjects)</span> </span>&#123;<br>        <span class="hljs-comment">// print message and deallocate memory with global delete</span><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;deallocate &quot;</span> &lt;&lt; numObjects &lt;&lt; <span class="hljs-string">&quot; element(s)&quot;</span><br>                    &lt;&lt; <span class="hljs-string">&quot; of size &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T)<br>                    &lt;&lt; <span class="hljs-string">&quot; at: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)dataPtr &lt;&lt; std::endl;<br>        <span class="hljs-built_in">freeShared</span>(dataPtr);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123;<br>        <span class="hljs-keyword">using</span> other = MyAllocator&lt;U&gt;;<br>    &#125;;<br><br>    <span class="hljs-comment">// return address of values</span><br>    <span class="hljs-function">pointer <span class="hljs-title">address</span> <span class="hljs-params">(reference value)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;value; &#125;<br>    <span class="hljs-function">const_pointer <span class="hljs-title">address</span> <span class="hljs-params">(const_reference value)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;value; &#125;<br><br>    <span class="hljs-comment">/* constructors and destructor</span><br><span class="hljs-comment">    * - nothing to do because the allocator has no state</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">MyAllocator</span>() <span class="hljs-keyword">throw</span>() &#123; &#125;<br>    <span class="hljs-built_in">MyAllocator</span>(<span class="hljs-type">const</span> MyAllocator&amp;) <span class="hljs-built_in">throw</span>() &#123; &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> U&gt;<br>        <span class="hljs-built_in">MyAllocator</span> (<span class="hljs-type">const</span> MyAllocator&lt;U&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; &#125;<br>    ~<span class="hljs-built_in">MyAllocator</span>() <span class="hljs-built_in">throw</span>() &#123; &#125;<br><br>    <span class="hljs-comment">// return maximum number of elements that can be allocated</span><br>    size_type <span class="hljs-built_in">max_size</span> () <span class="hljs-type">const</span> <span class="hljs-built_in">throw</span>() &#123;<br>        <span class="hljs-keyword">return</span> std::numeric_limits&lt;std::<span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">max</span>() / <span class="hljs-built_in">sizeof</span>(T);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// return that all specializations of this allocator are interchangeable</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> MyAllocator&lt;T1&gt;&amp;,<br>                <span class="hljs-type">const</span> MyAllocator&lt;T2&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> MyAllocator&lt;T1&gt;&amp;,<br>                <span class="hljs-type">const</span> MyAllocator&lt;T2&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure>

<p>必须满足以上条件，该分配器才会自动工作。参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.josuttis.com/cppcode/myalloc.hpp.html">myalloc.hpp</a></p>
<h2 id="条款12：对STL容器线程安全性的期待现实一些"><a href="#条款12：对STL容器线程安全性的期待现实一些" class="headerlink" title="条款12：对STL容器线程安全性的期待现实一些"></a>条款12：对STL容器线程安全性的期待现实一些</h2><p>C++ 中的<strong>容器并不是多线程安全的</strong>，因为这会带来很大的开销。容器在多线程情况下能够实现的操作如下：</p>
<ul>
<li><strong>多个读取者是安全的</strong>。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器。</li>
<li>对<strong>不同容器的多个写入者是安全的</strong>。多线程可以同时写不同的容器。</li>
</ul>
<p>如果想要实现一个多线程安全的容器，要求如下：</p>
<ul>
<li>在每次调用容器的成员函数期间都要锁定该容器。</li>
<li>在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器。</li>
<li>在每个在容器上调用的算法执行期间锁定该容器。（这事实上没有意义，因为，正如条款32所解释的，算法没有办法识别出它们正在操作的容器。不过，我们将在这里检验这个选项，因为它的教育意义在于看看为什么即使是可能的它也不能工作。）</li>
</ul>
<p>这带来很大的线程锁（同步原语，如信号量机制）的资源开销。</p>
<p>在 Morden C++ 中，可以使用信号量保证多线程的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    mutex m;<br><br>    &#123;<br>        <span class="hljs-comment">// 使用互斥锁 必须手动  lock  unlock</span><br>        m.<span class="hljs-built_in">lock</span>();<br>        for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>        m.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    &#123;<br>        <span class="hljs-comment">// unique_lock 使用 RAII, 保证锁会 自动上锁 和 释放</span><br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;<br>        for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Effective-STL/" class="category-chain-item">Effective STL</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/STL/" class="print-no-link">#STL</a>
      
        <a href="/tags/Effective-STL/" class="print-no-link">#Effective STL</a>
      
        <a href="/tags/Containers/" class="print-no-link">#Containers</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Effective STL - 01 - Containers</div>
      <div>http://hebangwen.github.io/2024/03/17/Containers/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>何榜文</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/17/Vector-and-String/" title="Effective STL - 02 - Vector and String">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Effective STL - 02 - Vector and String</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/14/zerotier-free-web/" title="使用zerotier实现免费上网">
                        <span class="hidden-mobile">使用zerotier实现免费上网</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
