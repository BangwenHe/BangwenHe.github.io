<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>opencl-alloc-error</title>
    <link href="/2024/03/27/opencl-alloc-error/"/>
    <url>/2024/03/27/opencl-alloc-error/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenCL-Image-申请失败"><a href="#OpenCL-Image-申请失败" class="headerlink" title="OpenCL Image 申请失败"></a>OpenCL Image 申请失败</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用 MNN 部署 ViT 的过程中，出现了这个报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Alloc Image 3 x 49152 error, code:-40<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个问题是因为这个图像的尺寸超过了本设备 OpenCL 支持的最大尺寸，Adreno 630 的最大尺寸是 16384x16384，所以这个图像的尺寸 3x49152 超过了这个限制。这个尺寸出现的地方在 ViT 生成 QKV 的时候，这个尺寸是 768x2304，使用 RGBA 四通道 Image 时，reshape 之后的尺寸就是 3x49152。解决方案：</p><ol><li>修改 MNN 的代码，将这个尺寸调整到小于 16384x16384。但是需要修改后续的计算代码</li><li>在导出模型时，不要将三个矩阵合并成一个矩阵进行计算，而是分开计算，这样就不会出现这个问题</li><li>Buffer 不会出错，可以使用 Buffer 代替 Image 进行计算，但是 MNN 没有自动 fallback 的功能，需要手动修改代码</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>opencl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 06 - Programming by STL</title>
    <link href="/2024/03/17/Programming-by-STL/"/>
    <url>/2024/03/17/Programming-by-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="Programming-by-STL"><a href="#Programming-by-STL" class="headerlink" title="Programming by STL"></a>Programming by STL</h1><h2 id="条款43：尽量用算法调用代替手写循环"><a href="#条款43：尽量用算法调用代替手写循环" class="headerlink" title="条款43：尽量用算法调用代替手写循环"></a>条款43：尽量用算法调用代替手写循环</h2><ul><li>如果你要做的是算法已经提供了的，或者非常接近于它提供的，调用泛型算法更清晰。</li><li>如果循环里要做的事非常简单，但调用算法时却需要使用绑定和适配器或者需要独立的仿函数类，你恐怕还是写循环比较好。</li><li>最后，如果你在循环里做的事相当长或相当复杂，天平再次倾向于算法。</li></ul><h2 id="条款44：尽量用成员函数代替同名的算法"><a href="#条款44：尽量用成员函数代替同名的算法" class="headerlink" title="条款44：尽量用成员函数代替同名的算法"></a>条款44：尽量用成员函数代替同名的算法</h2><p><strong>关联容器提供了count、find、lower_bound、upper_bound和equal_range，而list提供了remove、remove_if、unique、sort、merge和reverse。</strong>大多数情况下，你应该用成员函数代替算法。这样做有两个理由。首先，成员函数更快。其次，比起算法来，它们与容器结合得更好（尤其是关联容器）。那是因为同名的算法和成员函数通常并不是是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1&#x27;000&#x27;000</span>; i++)  s.<span class="hljs-built_in">insert</span>(i);<br><br><span class="hljs-comment">// 1ms</span><br><span class="hljs-comment">// 使用 rand 避免缓存</span><br><span class="hljs-built_in">benchmark</span>([&amp;s] () &#123;<br>    <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">rand</span>() % s.<span class="hljs-built_in">size</span>());<br>&#125;);<br><br><span class="hljs-comment">// 1809ms</span><br><span class="hljs-built_in">benchmark</span>([&amp;s] () &#123;<br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">rand</span>() % s.<span class="hljs-built_in">size</span>());<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>成员函数使用了与 关联容器 一致的等价算法，而 find 使用的是 相等 算法</strong>。因此，如果使用关联容器的话，你应该尽量使用成员函数形式的find、count、lower_bound等等，而不是同名的算法，因为这些成员函数版本提供了和其它成员函数一致的行为。</p><p>list成员函数的行为和它们的算法兄弟的行为经常不相同。正如条款32所解释的，如果你真的想从容器中清除对象的话，调用remove、remove_if和unique算法后，必须紧接着调用erase函数；但list的remove、remove_if和unique成员函数真的去掉了元素，后面不需要接着调用erase。</p><h2 id="条款45：注意count、find、binary-search、lower-bound、upper-bound和equal-range的区别"><a href="#条款45：注意count、find、binary-search、lower-bound、upper-bound和equal-range的区别" class="headerlink" title="条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别"></a>条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别</h2><table><thead><tr><th>你想知道的</th><th>在无序区间</th><th>在有序区间</th><th>在set或map上（成员函数）</th><th>在multiset或multimap上（成员函数）</th></tr></thead><tbody><tr><td>期望值是否存在？</td><td>find</td><td>binary_search</td><td>count</td><td>find</td></tr><tr><td>期望值是否存在？如果有，第一个等于这个值的对象在哪里？</td><td>find</td><td>equal_range</td><td>find</td><td>find或lower_bound（参见下面）</td></tr><tr><td>第一个不在期望值之前的对象在哪里？</td><td>find_if</td><td>lower_bound</td><td>lower_bound</td><td>lower_bound</td></tr><tr><td>第一个在期望值之后的对象在哪里？</td><td>find_if</td><td>upper_bound</td><td>upper_bound</td><td>upper_bound</td></tr><tr><td>有多少对象等于期望值？</td><td>count</td><td>equal_range，然后 distance</td><td>count</td><td>count</td></tr><tr><td>等于期望值的所有对象在哪里？</td><td>find（迭代）</td><td>equal_range</td><td>equal_range</td><td>equal_range</td></tr></tbody></table><ul><li>对于无序区间，大部分都是使用 find 或者 find_if</li><li>对于有序区间，可以使用 binary_search、lower_bound、upper_bound、equal_range</li><li>对于关联式容器，也可以用本身的成员函数</li></ul><h2 id="条款46：考虑使用函数对象代替函数作算法的参数"><a href="#条款46：考虑使用函数对象代替函数作算法的参数" class="headerlink" title="条款46：考虑使用函数对象代替函数作算法的参数"></a>条款46：考虑使用函数对象代替函数作算法的参数</h2><p>如果一个函数对象的operator()函数被声明为内联（不管显式地通过inline或者隐式地通过定义在它的类定义中），编译器就可以获得那个函数的函数体，而且大部分编译器喜欢在调用算法的模板实例化时内联那个函数。在上面的例子中，greater<double>::operator()是一个<strong>内联函数</strong>，所以编译器在实例化sort时内联展开它。</p><p>它传了一个doubleGreater的指针，而指针的调用存在开销。</p><p>不过我实际测试来看，没有什么区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % (n / <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 6985ms</span><br><span class="hljs-built_in">benchmark</span>&lt;<span class="hljs-number">100</span>&gt;([&amp;v] () &#123;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>&#125;);<br><br><span class="hljs-comment">// 6843ms</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  v[i] = <span class="hljs-built_in">rand</span>() % (n / <span class="hljs-number">2</span>);<br><span class="hljs-built_in">benchmark</span>&lt;<span class="hljs-number">100</span>&gt;([&amp;v] () &#123;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-keyword">auto</span>&amp; lhs, <span class="hljs-keyword">auto</span>&amp; rhs) &#123;<br>        <span class="hljs-keyword">return</span> lhs &gt; rhs;<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 7134ms</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  v[i] = <span class="hljs-built_in">rand</span>() % (n / <span class="hljs-number">2</span>);<br><span class="hljs-built_in">benchmark</span>&lt;<span class="hljs-number">100</span>&gt;([&amp;v] () &#123;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>&#125;);<br></code></pre></td></tr></table></figure><p>把函数对象作为算法的参数所带来的不仅是巨大的效率提升。在让你的代码可以编译方面，它们也更稳健。当然，真函数很有用，但是当涉及有效的STL编程时，函数对象经常更有用。</p><h2 id="条款47：避免产生只写代码"><a href="#条款47：避免产生只写代码" class="headerlink" title="条款47：避免产生只写代码"></a>条款47：避免产生只写代码</h2><p><strong>代码的读比写更经常，这是软件工程的真理</strong>。也就是说软件的维护比开发花费多得多的时间。不能读和理解的软件不能被维护，不能维护的软件几乎没有不值得拥有。你用STL越多，你会感到它越来越舒适，而且你会越来越多的使用嵌套函数调用和即时（on the fly）建立函数对象。这没有什么错的，但永远记住你今天写的代码会被某个人——也可能是你——在未来的某一天读到。为那天做准备吧</p><h2 id="条款48：总是-include适当的头文件"><a href="#条款48：总是-include适当的头文件" class="headerlink" title="条款48：总是#include适当的头文件"></a>条款48：总是#include适当的头文件</h2><ul><li>几乎所有的容器都在同名的头文件里，比如，vector在<vector>中声明，list在<list>中声明等。例外的是<set>和<map>。<set>声明了set和multiset，<map>声明了map和multimap。</li><li>除了四个算法外，所有的算法都在<algorithm>中声明。例外的是accumulate（参见条款37）、inner_product、adjacent_difference和partial_sum。这些算法在<numeric>中声明。</li><li>特殊的迭代器，包括istream_iterators和istreambuf_iterators（参见条款29），在<iterator>中声明。</li><li>标准仿函数（比如less<T>）和仿函数适配器（比如not1、bind2nd）在<functional>中声明。</li></ul><h2 id="条款49：学习破解有关STL的编译器诊断信息"><a href="#条款49：学习破解有关STL的编译器诊断信息" class="headerlink" title="条款49：学习破解有关STL的编译器诊断信息"></a>条款49：学习破解有关STL的编译器诊断信息</h2><p>这里有一些应该能帮助你理解有关STL的编译器消息的其它提示：</p><ul><li><p>对于vector和string，迭代器有时是指针，所以如果你用迭代器犯了错误，编译器诊断信息可能会提及涉及指针类型。例如，如果你的源代码涉及vector<double>::iterator，编译器消息有时会提及double<em>指针。</em>（一个值得注意的例外是当你使用来自STLport的STL实现，而且你运行在调试模式。那样的话，vector和string的迭代器干脆不是指针。对STLport和它调试模式的更多信息，转向条款50。）</p></li><li><p><strong>提到back_insert_iterator、front_insert_iterator或insert_iterator的消息经常意味着你错误调用了back_inserter、front_inserter或inserter，一一对应</strong>，（back_inserter返回back_insert_iterator类型的对象，front_inserter返回front_insert_iterator类型的对象，而inserter返回insert_iterator类型的对象。关于使用这些inserter的信息，参考条款30。）如果你没有调用这些函数，你（直接或间接）调用的一些函数做了。</p></li><li><p>类似地，<strong>如果你得到的一条消息提及binder1st或binder2nd，你或许错误地使用了bind1st或bind2nd</strong>。（bind1st返回binder1st类型的对象，而bind2nd返回binder2nd类型的对象。）</p></li><li><p>输出迭代器（例如ostream_iterator、ostreambuf_iterators（参见条款29），和从back_inserter、front_inserter和inserter返回的迭代器）在赋值操作符内部做输出或插入工作，所以如果你错误使用了这些迭代器类型之一，你很可能得到一条消息，抱怨在你从未听说过的一个赋值操作符里的某个东西。为了明白我的意思，试着编译这段代码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v; <span class="hljs-comment">// 试图打印一个</span><br><span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-comment">// string*指针的容器，</span><br>  <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">&quot;\n&quot;</span>)); <span class="hljs-comment">// 被当作string对象 </span><br></code></pre></td></tr></table></figure></li><li><p>你得到一条源于STL算法实现内部的错误信息（即，源代码引发的错误在<algorithm>中），也许是<strong>你试图给那算法用的类型出错了</strong>。例如，你可能传了错误种类的迭代器。要看看这样的用法错误是怎样报告的，通过把这段代码喂给你的编译器来启发（并愉快！）自己：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt;::iterator i1, i2; <span class="hljs-comment">// 把双向迭代器</span><br><span class="hljs-built_in">sort</span>(i1, i2); <span class="hljs-comment">// 传给一个需要 // 随机访问迭代器的算法 </span><br></code></pre></td></tr></table></figure></li><li><p>你使用常见的STL组件比如vector、string或for_each算法，而编译器说不知道你在说什么，你也许没有#include一个需要的头文件。正如条款48的解释，这问题会降临在长期以来都可以顺利编译而刚移植到新平台的代码</p></li></ul><p>有经验的STL程序员发展出一项类似的技能。他们可以不假思索地在内部把比如std::basic_string&lt;char, struct std::char_traits<char>, class std::allocator<char> &gt;翻译为string。你也要发展这项技能，但在你能做到之前，记得你总是可以通过用更短的记忆术替换冗长的基于模板的类型名字来把编译器诊断信息降低到可以理解的东西。</p><h2 id="条款50：让你自己熟悉有关STL的网站"><a href="#条款50：让你自己熟悉有关STL的网站" class="headerlink" title="条款50：让你自己熟悉有关STL的网站"></a>条款50：让你自己熟悉有关STL的网站</h2><ul><li>SGI STL网站，<a href="http://www.sgi.com/tech/stl/%E3%80%82">http://www.sgi.com/tech/stl/。</a></li><li>STLport网站，<a href="http://www.stlport.org/%E3%80%82">http://www.stlport.org/。</a></li><li>Boost网站，<a href="http://www.boost.org/%E3%80%82%EF%BC%88%E8%AF%91%E6%B3%A8%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%95%E8%AF%95http://boost.sourceforge.net/%EF%BC%89">http://www.boost.org/</a>。如果无法访问，尝试：<a href="https://www.boost.org/">Boost C++ Libraries</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 05 - Functor</title>
    <link href="/2024/03/17/Functor/"/>
    <url>/2024/03/17/Functor/</url>
    
    <content type="html"><![CDATA[<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><h2 id="条款38：把仿函数类设计为用于值传递"><a href="#条款38：把仿函数类设计为用于值传递" class="headerlink" title="条款38：把仿函数类设计为用于值传递"></a>条款38：把仿函数类设计为用于值传递</h2><p>C 中的 <strong>qsort 使用的  函数指针  就是指针的拷贝</strong>，因此是一个默认的值传递。</p><p>因为函数对象以值传递和返回，你的任务就是确保当那么传递（也就是拷贝）时你的函数对象行为良好。这暗示了两个东西。第一，<strong>你的函数对象应该很小</strong>。否则它们的拷贝会很昂贵。第二，你的<strong>函数对象必须单态（也就是，非多态）</strong>——它们不能用虚函数。</p><p>不是所有的仿函数都是小的、单态的。函数对象比真的函数优越的的原因之一是<strong>仿函数可以包含你需要的所有状态</strong>。有些函数对象自然会很重，保持传这样的仿函数给STL算法和传它们的函数版本一样容易是很重要的。（像之前提到的算法中 <a href="https://www.notion.so/Algorithms-0ddf57ef2cb7451e9dbb5a57c5b9c427?pvs=21">Algorithms</a> ，Points 类就使用了 PointsAverage 来保存对应的状态，我的实现使用了 lambda 和引用来保存求和的结果）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用 Bridge 模式</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 用于修改的BPFC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BPFCImpl</span>:<br> <span class="hljs-keyword">public</span> unary_function&lt;T, <span class="hljs-type">void</span>&gt; &#123; <span class="hljs-comment">// 的新实现类</span><br><span class="hljs-keyword">private</span>:<br> Widget w; <span class="hljs-comment">// 以前在BPFC里的所有数据</span><br> <span class="hljs-type">int</span> x; <span class="hljs-comment">// 现在在这里</span><br> ...<br> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">BPFCImpl</span>(); <span class="hljs-comment">// 多态类需要</span><br> <span class="hljs-comment">// 虚析构函数</span><br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPFC</span>&lt;T&gt;; <span class="hljs-comment">// 让BPFC可以访问这些数据</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BPFC</span>:<br> <span class="hljs-keyword">public</span> unary_function&lt;T, <span class="hljs-type">void</span>&gt; &#123;  <span class="hljs-comment">// 小的，单态版的BPFC</span><br><span class="hljs-keyword">private</span>:<br> BPFCImpl&lt;T&gt; *pImpl; <span class="hljs-comment">// 这是BPFC唯一的数据</span><br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 现在非虚；</span></span><br><span class="hljs-function"> </span>&#123; <span class="hljs-comment">// 调用BPFCImpl的</span><br> pImpl-&gt;<span class="hljs-built_in">operator</span>() (val);<br> &#125;<br> ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为我勾勒出的基本技术在C++圈子中已经广为人知了。《Effective C++》的条款34中有。在Gamma等的《设计模式》[6]中，这叫做<strong>“Bridge模式”</strong>。Sutter在他的《Exceptional C++》[8]中叫它“Pimpl惯用法”。</p><p>从STL的视角看来，要记住的最重要的东西是使用这种技术的仿函数类必须支持合理方式的拷贝。如果你是上面BPFC的作者，你就必须保证它的拷贝构造函数对指向的BPFCImpl对象做了合理的事情。</p><h2 id="条款39：用纯函数做判断式"><a href="#条款39：用纯函数做判断式" class="headerlink" title="条款39：用纯函数做判断式"></a>条款39：用纯函数做判断式</h2><p>判断式是返回bool（或者其他可以隐式转化为bool的东西）。判断式在STL中广泛使用。标准关联容器的比较函数是判断式，判断式函数常常作为参数传递给算法，比如find_if和多种排序算法。（排序算法的概览可以在条款31找到。）：</p><ul><li><strong>纯函数是返回值只依赖于参数的函数</strong>。如果f是一个纯函数，x和y是对象，f(x, y)的返回值仅当x或y的值改变的时候才会改变。 在C++中，由纯函数引用的所有数据不是作为参数传进的就是在函数生存期内是常量。（一般，这样的常量应该声明为const。）如果一个纯函数引用的数据在不同次调用中可能改变，在不同的时候用同样的参数调用这个函数可能导致不同的结果，那就与纯函数的定义相反。</li><li><strong>一个判断式类是一个仿函数类，它的operator()函数是一个判断式，也就是，它的operator()返回true或false（或其他可以隐式转换到true或false的东西）</strong>。正如你可以预料到的，任何STL想要一个判断式的地方，它都会接受一个真的判断式或一个判断式类对象。</li></ul><p>在很多算法里的要求如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">find_if</span>(InputIt begin, InputIt end, Pred pred);<br></code></pre></td></tr></table></figure><p>这里的 Pred 就是一个判断式（谓语，主谓宾，谓语只起到连接主语和宾语的用途），全称叫做 Predicate。</p><p>对于判断式来说，不要包含任何的状态：</p><ul><li>对于函数，就是不要含有可变的 static 变量，且影响到函数的返回结果</li><li>对于函数对象，不要改变类成员</li><li>对于以上二者，不要调用任何的全局 static 变量</li></ul><h2 id="条款40：使仿函数类可适配"><a href="#条款40：使仿函数类可适配" class="headerlink" title="条款40：使仿函数类可适配"></a>条款40：使仿函数类可适配</h2><p>一个普通的仿函数类只需要实现自己的 <code>operator()</code> 方法即可，但是这样可以无法应用于一些适配器，例如 <code>not1</code> 、<code>bind2nd</code> 等。</p><p>为了使得自己实现的仿函数类可适配，需要实现一些 typedef，应该是提供给调用者的 traits。一般的做法是继承 <code>unary_function</code> 或者 <code>binary_function</code> 。<strong>提供这些必要的typedef的函数对象称为可适配的，而缺乏那些typedef的函数对象不可适配。可适配的比不可适配的函数对象可以用于更多的场景，所以只要能做到你就应该使你的函数对象可适配。</strong></p><p>operator()带一个实参的仿函数类，要继承的结构是std::unary_function。operator()带有两个实参的仿函数类，要继承的结构是std::binary_function。</p><p><strong>bind 替代的是 bind1st、bind2nd，<code>std::function</code> 替代的是上面提到的 std::unary_function 以及 std::binary_function。</strong></p><p>本条款的主题就是，如果你写了一个仿函数类，最好根据仿函数类的操作，继承上 unary_function 和 binary_function 使得仿函数类可适配。</p><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">必须继承 binary_function, 否则没有 first_argument_type second_argument_type 等 类型</span><br><span class="hljs-comment">也可以使用 C++ 11 推出的 std::function 替代上面的二者</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyCmp</span> : binary_function&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; &#123;<br><span class="hljs-comment">// struct MyCmp : std::function&lt;bool (int, int)&gt; &#123;</span><br><span class="hljs-comment">// struct MyCmp &#123;</span><br>    <span class="hljs-comment">// 一个 Predicate 不应该有自己的状态</span><br>    <span class="hljs-comment">// 因此不应该修改类内的元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">编写一个自己实现的  可适配的仿函数类, 而不是一个 binder</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FirstArg, <span class="hljs-keyword">typename</span> SecondArg, <span class="hljs-keyword">typename</span> RetArg&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyCmp2</span> &#123;<br>    <span class="hljs-keyword">using</span> first_argument_type = FirstArg;<br>    <span class="hljs-keyword">using</span> second_argument_type = SecondArg;<br>    <span class="hljs-keyword">using</span> result_type = RetArg;<br><br>    <span class="hljs-function">RetArg <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FirstArg first, SecondArg second)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first &lt; second;<br>    &#125;<br>&#125;;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;  <span class="hljs-comment">// 0 1 2</span><br><span class="hljs-built_in">copy_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(v2), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">MyCmp</span>(), <span class="hljs-number">3</span>));<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v3;  <span class="hljs-comment">// 3 4 5</span><br><span class="hljs-built_in">copy_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(v3), <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">MyCmp2</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt;(), <span class="hljs-number">3</span>)));<br></code></pre></td></tr></table></figure><h2 id="条款41：了解使用ptr-fun、mem-fun和mem-fun-ref的原因"><a href="#条款41：了解使用ptr-fun、mem-fun和mem-fun-ref的原因" class="headerlink" title="条款41：了解使用ptr_fun、mem_fun和mem_fun_ref的原因"></a>条款41：了解使用ptr_fun、mem_fun和mem_fun_ref的原因</h2><p>STL 中有三种函数调用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test</span>(p);        <span class="hljs-comment">// STL 默认接受</span><br>p.<span class="hljs-built_in">test</span>();       <span class="hljs-comment">// 成员函数, 需要 mem_fun 适配器</span><br>(&amp;p)-&gt;<span class="hljs-built_in">test</span>();   <span class="hljs-comment">// 成员函数, 指针运算符调用, 需要 mem_fun_ref 适配器</span><br></code></pre></td></tr></table></figure><p>STL 默认只接受第一种写法。</p><p>一个与ptr_fun有关的可选策略是<strong>只有当你被迫时才使用它</strong>。如果当typedef是必要时你忽略了它，你的编译器将退回你的代码。然后你得返回去添加它。mem_fun和mem_fun_ref的情况则完全不同。<strong>只要你传一个成员函数给STL组件，你就必须使用它们</strong>，因为，除了增加typedef（可能是或可能不是必须的）之外，它们把调用语法从一个通常用于成员函数的适配到在STL中到处使用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    T x, y;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意: 只有 Point&lt;float&gt;* 的容器才能调用 mem_fun(&amp;Point&lt;float&gt;::print)</span><br><span class="hljs-comment">因为 mem_fun 的实现里面调用了指针运算符, 所以对象不能调用</span><br><span class="hljs-comment">对应的, mem_fun_ref 调用了  成员运算符, 所以指针不能调用</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;Point&lt;<span class="hljs-type">float</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">0.3f</span>, <span class="hljs-number">0.9f</span>&#125;, &#123;<span class="hljs-number">1.6f</span>, <span class="hljs-number">2.4f</span>&#125;, &#123;<span class="hljs-number">4.1f</span>, <span class="hljs-number">5.2f</span>&#125;&#125;;<br>    vector&lt;Point&lt;<span class="hljs-type">float</span>&gt;*&gt; vpPtr = &#123;&amp;vp[<span class="hljs-number">0</span>], &amp;vp[<span class="hljs-number">1</span>], &amp;vp[<span class="hljs-number">2</span>]&#125;;<br>    for_each(vpPtr.<span class="hljs-built_in">begin</span>(), vpPtr.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun</span>(&amp;Point&lt;<span class="hljs-type">float</span>&gt;::print));<br>    for_each(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Point&lt;<span class="hljs-type">float</span>&gt;::print));<br>&#125;<br></code></pre></td></tr></table></figure><p>mem_fun 和 mem_fun_ref 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Result</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_mem_fun_t</span> : <span class="hljs-keyword">public</span> unary_function&lt;<span class="hljs-type">const</span> _Ty*, _Result&gt; &#123; <span class="hljs-comment">// functor adapter (*p-&gt;*pfunc)(), const *pfunc</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">const_mem_fun_t</span><span class="hljs-params">(_Result (_Ty::*_Pm)() <span class="hljs-type">const</span>)</span> : _Pmemfun(_Pm) &#123;</span>&#125;<br><br>    <span class="hljs-function">_Result <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> _Ty* _Pleft)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (_Pleft-&gt;*_Pmemfun)();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    _Result (_Ty::*_Pmemfun)() <span class="hljs-type">const</span>; <span class="hljs-comment">// the member function pointer</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Result</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-type">const_mem_fun_t</span>&lt;_Result, _Ty&gt; <span class="hljs-title">mem_fun</span><span class="hljs-params">(_Result (_Ty::*_Pm)() <span class="hljs-type">const</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_mem_fun_t</span>&lt;_Result, _Ty&gt;(_Pm);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Result</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_mem_fun_ref_t</span> : <span class="hljs-keyword">public</span> unary_function&lt;_Ty, _Result&gt; &#123; <span class="hljs-comment">// functor adapter (*left.*pfunc)(), const *pfunc</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">const_mem_fun_ref_t</span><span class="hljs-params">(_Result (_Ty::*_Pm)() <span class="hljs-type">const</span>)</span> : _Pmemfun(_Pm) &#123;</span>&#125;<br><br>    <span class="hljs-function">_Result <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> _Ty&amp; _Left)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (_Left.*_Pmemfun)();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    _Result (_Ty::*_Pmemfun)() <span class="hljs-type">const</span>; <span class="hljs-comment">// the member function pointer</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Result</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-type">const_mem_fun_ref_t</span>&lt;_Result, _Ty&gt; <span class="hljs-title">mem_fun_ref</span><span class="hljs-params">(_Result (_Ty::*_Pm)() <span class="hljs-type">const</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_mem_fun_ref_t</span>&lt;_Result, _Ty&gt;(_Pm);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款42：确定less表示operator"><a href="#条款42：确定less表示operator" class="headerlink" title="条款42：确定less表示operator&lt;"></a>条款42：确定less<T>表示operator&lt;</h2><p><strong>operator&lt;不仅是实现less的默认方式，它还是程序员希望less做的</strong>。让less做除operator&lt;以外的事情是对程序员预期的无故破坏。它与所被称为“最小惊讶的原则”相反。它是冷淡的。它是低劣的。它是坏的。你不该那么做。</p><p>如果你<strong>使用less（明确或者隐含），保证它表示operator&lt;<strong>。如果你想要</strong>使用一些其他标准排序对象，建立一个特殊的不叫做less的仿函数类</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Functor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 04 - Algorithms</title>
    <link href="/2024/03/17/Algorithms/"/>
    <url>/2024/03/17/Algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h1><h2 id="条款30：确保目标区间足够大"><a href="#条款30：确保目标区间足够大" class="headerlink" title="条款30：确保目标区间足够大"></a>条款30：确保目标区间足够大</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>cout &lt;&lt; v &lt;&lt; endl;<br><br><span class="hljs-comment">// 对于使用区间的函数, 注意预先分配空间</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>v2.<span class="hljs-built_in">reserve</span>(v.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(v2), [] (<span class="hljs-type">int</span>&amp; a) &#123;<br>    <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>;<br>&#125;);<br>cout &lt;&lt; v2 &lt;&lt; endl;<br><br>v2.<span class="hljs-built_in">reserve</span>(v.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(v2), <br>    <span class="hljs-built_in">bind</span>(<span class="hljs-built_in">multiplies</span>&lt;<span class="hljs-type">int</span>&gt;(), placeholders::_1, <span class="hljs-number">2</span>));<br>cout &lt;&lt; v2 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>注意：<code>back_inserter</code> 会调用 <code>push_back</code> ，所以只能用于标准序列容器，即 vector、list、deque、string。（array 的迭代器没有 insert 方法，因此不能使用）</p><p>无论何时你使用一个要求指定目的区间的算法，<strong>确保目的区间已经足够大或者在算法执行时可以增加大小（array就不能增加大小）</strong>。如果你选择增加大小，就<strong>使用插入迭代器，比如ostream_iterators或从back_inserter、front_inserter或inserter返回的迭代器</strong>。这是所有你需要记住的东西。</p><h2 id="条款31：了解你的排序选择"><a href="#条款31：了解你的排序选择" class="headerlink" title="条款31：了解你的排序选择"></a>条款31：了解你的排序选择</h2><p>我们总结一下你的排序选择：</p><ul><li>如果你需要在vector、string、deque或数组上进行完全排序，你可以使用sort或stable_sort。</li><li>如果你有一个vector、string、deque或数组，你只需要排序前n个元素，应该用partial_sort。</li><li>如果你有一个vector、string、deque或数组，你需要鉴别出第n个元素或你需要鉴别出最前的n个元素，而不用知道它们的顺序，nth_element是你应该注意和调用的。</li><li>如果你需要把标准序列容器的元素或数组<strong>分隔为满足和不满足某个标准</strong>，你大概就要找partition或stable_partition。</li><li>如果你的数据是在list中，你可以直接使用partition和stable_partition，你可以使用list的sort来代替sort和stable_sort。如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务，但正如我在上面勾画的，会有很多选择。</li></ul><p>下面是使用 partition 实现快排的算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (begin &gt;= end - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// partition 的任务: 找到 pivot 的 upperBound</span><br>  <span class="hljs-type">int</span> pivot = v[begin];<br>  <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">partition</span>(v.<span class="hljs-built_in">begin</span>() + begin, v.<span class="hljs-built_in">begin</span>() + end, [&amp;pivot] (<span class="hljs-type">int</span>&amp; i) &#123;<br>      <span class="hljs-keyword">return</span> i &lt;= pivot;<br>  &#125;);<br><br>  <span class="hljs-comment">// 更新 pivot 的位置</span><br>  <span class="hljs-built_in">swap</span>(*(v.<span class="hljs-built_in">begin</span>() + begin), *(--it));<br>  <span class="hljs-built_in">qsort</span>(v, begin, it - v.<span class="hljs-built_in">begin</span>());<br>  <span class="hljs-built_in">qsort</span>(v, it - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RndIt&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">const</span> RndIt&amp; begin, <span class="hljs-type">const</span> RndIt&amp; end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (begin &gt;= end - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">partition</span>(begin, end, <br>        <span class="hljs-built_in">bind</span>(<span class="hljs-built_in">less_equal</span>&lt;<span class="hljs-keyword">typename</span> RndIt::value_type&gt;(), placeholders::_1, *begin));<br>    <span class="hljs-built_in">swap</span>(*begin, *(--it));<br>    <span class="hljs-built_in">qsort</span>(begin, it);<br>    <span class="hljs-built_in">qsort</span>(it + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase"><a href="#条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase" class="headerlink" title="条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase"></a>条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase</h2><p><strong>remove并不“真的”删除东西，因为它做不到。只有容器成员函数可以除去容器元素，而那是本条款的整个要点：如果你真的要删除东西的话，你应该在remove后面接上erase。</strong></p><p>remove移动指定区间中的元素直到所有“不删除的”元素在区间的开头（相对位置和原来它们的一样）。它返回一个指向最后一个的下一个“不删除的”元素的迭代器。返回值是区间的“新逻辑终点”。remove 不会保留所有值，因为那些值是不必要的了。（所以<strong>不能使用 remove_if 对数组进行排序</strong>）</p><p>你要记住的唯一其他的东西是remove不是唯一这种情况的算法。另外有两种“类似remove”的算法：remove_if和unique。remove和remove_if之间的相似性很直截了当。所以我不会细讲，但<strong>unique行为也像remove。它用来从一个区间删除东西（邻近的重复值）而不用访问持有区间元素的容器</strong>。unique 应该就类似 <code>np.unique</code> ，用于保留一份拷贝。</p><h2 id="条款33：提防在指针的容器上使用类似remove的算法"><a href="#条款33：提防在指针的容器上使用类似remove的算法" class="headerlink" title="条款33：提防在指针的容器上使用类似remove的算法"></a>条款33：提防在指针的容器上使用类似remove的算法</h2><p>因为一旦指针被替换，内存就泄露了。可以使用智能指针，能够实现自由释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; v;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> size = <span class="hljs-number">100&#x27;000</span>;<br>v.<span class="hljs-built_in">reserve</span>(size);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)  v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(i));<br><br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-keyword">auto</span>&amp; elm) &#123;<br>    <span class="hljs-keyword">return</span> *elm &lt; <span class="hljs-number">30</span>;<br>&#125;), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="条款34：注意哪个算法需要有序区间"><a href="#条款34：注意哪个算法需要有序区间" class="headerlink" title="条款34：注意哪个算法需要有序区间"></a>条款34：注意哪个算法需要有序区间</h2><p>我知道你们中的一部分会用蛮力记忆，所以这里有一个只能操作有序数据的算法的表：</p><table><thead><tr><th>binary_search</th><th>lower_bound</th></tr></thead><tbody><tr><td>upper_bound</td><td>equal_range</td></tr><tr><td>set_union</td><td>set_intersection</td></tr><tr><td>set_difference</td><td>set_symmetric_difference</td></tr><tr><td>merge</td><td>inplace_merge</td></tr><tr><td>includes</td><td></td></tr></tbody></table><p>另外，下面的算法一般用于有序区间，虽然它们不要求：</p><table><thead><tr><th>unique</th><th>unique_copy</th></tr></thead></table><p><strong>搜索算法binary_search、lower_bound、upper_bound和equal_range（参见条款45）需要有序区间，因为它们使用二分法查找来搜索值</strong>。像C库中的bsearch，这些算法保证了对数时间的查找，但作为交换的是，你必须给它们已经排过序的值。实际上，这些算法保证对数时间查找不是很正确。仅当传给它们的是<strong>随机访问迭代器</strong>时它们才能保证有那样的性能。如果给它们威力比较小的迭代器（比如双向迭代器），它们仍然进行对数次比较，但运行是线性时间的。那是因为，缺乏进行“迭代器算术（arithmetic）”的能力。<strong>它们在搜索的区间中需要花费线性时间来从一个地方移动到另一个地方</strong>。</p><p><strong>算法set_union（交集）、set_intersection（并集）、set_difference（异或）和set_symmetric_difference（同或） 的四人组提供了线性时间设置它们名字所提出的操作的性能。</strong>为什么它们需要有序区间？因为如果不是的话，它们不能以线性时间完成它们的工作。如果你开始发觉一个趋势——需要有序区间的算法为了比它们用于可能无序区间提供更好的性能而这么做，你是对的。</p><p>merge和inplace_merge执行了<strong>有效的单遍合并排序算法</strong>：它们读取两个有序区间，然后产生一个包含了两个源区间所有元素的新有序区间。它们以线性时间执行，如果它们不知道源区间已经有序就不能完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (begin &gt;= end - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;v.<span class="hljs-built_in">begin</span>() + begin, v.<span class="hljs-built_in">begin</span>() + end&#125;;<br><br>    <span class="hljs-type">int</span> mid = begin + ((end - begin) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">mergeSort</span>(v, begin, mid);<br>    <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">mergeSort</span>(v, mid, end);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    result.<span class="hljs-built_in">reserve</span>(end - begin);<br>    <span class="hljs-built_in">merge</span>(left.<span class="hljs-built_in">begin</span>(), left.<span class="hljs-built_in">end</span>(), right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(result));<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个需要有序区间的算法是includes。它用来检测是否<strong>一个区间的所有对象也在另一个区间</strong>中。因为includes可能假设它的两个区间都已经有序，所以它保证了线性时间性能。没有那个保证，一般来说它会变慢。</p><h2 id="条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较"><a href="#条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较" class="headerlink" title="条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较"></a>条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较</h2><p>使用 tolower 可以将字符串全部变成小写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ciCharCompare</span><span class="hljs-params">(<span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2)</span> </span>&#123;<br>    c1 = <span class="hljs-built_in">tolower</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(c1));<br>    c2 = <span class="hljs-built_in">tolower</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(c2));<br><br>    <span class="hljs-keyword">return</span> c1 &gt; c2 ? <span class="hljs-number">1</span> : c1 &lt; c2 ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 mismatch 对字符串进行匹配</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ciMismatchCompareImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span> </span>&#123;<br>    <span class="hljs-comment">// bind 修改  最后一个函数的意义, 当字符相等时返回 true, 不等时返回 false</span><br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">mismatch</span>(s1.<span class="hljs-built_in">begin</span>(), s1.<span class="hljs-built_in">end</span>(), s2.<span class="hljs-built_in">begin</span>(), s2.<span class="hljs-built_in">end</span>(), <br>        <span class="hljs-built_in">bind</span>([] (<span class="hljs-keyword">auto</span>&amp; c1, <span class="hljs-keyword">auto</span>&amp; c2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">ciCharCompare</span>(c1, c2) == <span class="hljs-number">0</span>;<br>        &#125;, placeholders::_1, placeholders::_2));<br>    <span class="hljs-keyword">if</span> (it.first == s1.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">// s1 是短字符串, 因此当短字符串结束后, 长字符串还没有结束</span><br>        <span class="hljs-comment">// 说明 s1 &lt; s2, 否则二者相等</span><br>        <span class="hljs-keyword">if</span> (it.second == s2.<span class="hljs-built_in">end</span>())  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 二者均没有到达结尾时, 由不相等字符决定</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ciCharCompare</span>(*it.first, *it.second);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ciMismatchCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() &gt;= s2.<span class="hljs-built_in">size</span>())  <span class="hljs-keyword">return</span> -<span class="hljs-built_in">ciMismatchCompareImpl</span>(s2, s1);<br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ciMismatchCompareImpl</span>(s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ciLexicographicalCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lexicographical_compare</span>(s1.<span class="hljs-built_in">begin</span>(), s1.<span class="hljs-built_in">end</span>(), <br>        s2.<span class="hljs-built_in">begin</span>(), s2.<span class="hljs-built_in">end</span>(),<br>        [] (<span class="hljs-keyword">auto</span>&amp; c1, <span class="hljs-keyword">auto</span>&amp; c2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">tolower</span>(c1) &lt; <span class="hljs-built_in">tolower</span>(c2);<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款36：了解copy-if的正确实现"><a href="#条款36：了解copy-if的正确实现" class="headerlink" title="条款36：了解copy_if的正确实现"></a>条款36：了解copy_if的正确实现</h2><p>目前 MSVC 已经有了 copy_if 的实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_InIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_OutIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Pr</span>&gt;<br><span class="hljs-function">_CONSTEXPR20 _OutIt <span class="hljs-title">copy_if</span><span class="hljs-params">(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)</span> </span>&#123; <span class="hljs-comment">// copy each satisfying _Pred</span><br>    _Adl_verify_range(_First, _Last);<br>    <span class="hljs-keyword">auto</span> _UFirst      = _Get_unwrapped(_First);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> _ULast = _Get_unwrapped(_Last);<br>    <span class="hljs-keyword">auto</span> _UDest       = _Get_unwrapped_unverified(_Dest);<br>    <span class="hljs-keyword">for</span> (; _UFirst != _ULast; ++_UFirst) &#123;<br>        <span class="hljs-keyword">if</span> (_Pred(*_UFirst)) &#123;<br>            *_UDest = *_UFirst;<br>            ++_UDest;<br>        &#125;<br>    &#125;<br><br>    _Seek_wrapped(_Dest, _UDest);<br>    <span class="hljs-keyword">return</span> _Dest;<br>&#125;<br></code></pre></td></tr></table></figure><p>STL有很多有趣的地方，其中一个是虽然有11个名字带“copy”的算法：</p><table><thead><tr><th>copy</th><th>copy_backward</th></tr></thead><tbody><tr><td>replace_copy</td><td>reverse_copy</td></tr><tr><td>replace_copy_if</td><td>unique_copy</td></tr><tr><td>remove_copy</td><td>rotate_copy</td></tr><tr><td>remove_copy_if</td><td>partial_sort_copy</td></tr><tr><td>unintialized_copy</td><td></td></tr></tbody></table><h2 id="条款37：用accumulate或for-each来统计区间"><a href="#条款37：用accumulate或for-each来统计区间" class="headerlink" title="条款37：用accumulate或for_each来统计区间"></a>条款37：用accumulate或for_each来统计区间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;&lt; endl;<br><br>vector&lt;Point&lt;<span class="hljs-type">float</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.1f</span>&#125;, &#123;<span class="hljs-number">1.3f</span>, <span class="hljs-number">4.2f</span>&#125;, &#123;<span class="hljs-number">3.6f</span>, <span class="hljs-number">9.1f</span>&#125;&#125;;<br>cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>(), Point&lt;<span class="hljs-type">float</span>&gt;&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;, [] (<span class="hljs-keyword">auto</span>&amp; v, <span class="hljs-keyword">auto</span>&amp; res) &#123;<br>    <span class="hljs-keyword">return</span> Point&lt;<span class="hljs-type">float</span>&gt;&#123;v.x + res.x, v.y + res.y&#125;;<br>&#125;) / <span class="hljs-built_in">float</span>(vp.<span class="hljs-built_in">size</span>()) &lt;&lt; endl;<br><br>Point&lt;<span class="hljs-type">float</span>&gt; startValue&#123;<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>&#125;;<br>for_each(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>(), [&amp;startValue] (<span class="hljs-keyword">auto</span>&amp; p) &#123;<br>    startValue += p;<br>&#125;);<br>cout &lt;&lt; startValue / <span class="hljs-built_in">float</span>(vp.<span class="hljs-built_in">size</span>()) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>accumulate 返回的是  容器的元素，for_each 返回的是  lambda 或者 仿函数对象。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 03 - Iterator</title>
    <link href="/2024/03/17/Iterator/"/>
    <url>/2024/03/17/Iterator/</url>
    
    <content type="html"><![CDATA[<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><h2 id="条款26：尽量用iterator代替const-iterator，reverse-iterator和const-reverse-iterator"><a href="#条款26：尽量用iterator代替const-iterator，reverse-iterator和const-reverse-iterator" class="headerlink" title="条款26：尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator"></a>条款26：尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</h2><!-- ![Untitled](Iterator%204258df646f7a402ba382ea5e60177a25/Untitled.png) --><pre><code class=" mermaid">graph A[iterator] --&gt; B[const_iterator]A[iterator] --&gt; C[reverse_iterator]C[reverse_iterator] --&gt; D[const_reverse_iterator]C[reverse_iterator] --&gt;|base| A[iterator]D[const_reverse_iterator] --&gt;|base| B[const_iterator]</code></pre><p>iterator 能够比 const_iterator 有更好的泛化性能，特别是对于 <code>insert</code> 、<code>erase</code> 函数，他们只支持 iterator 而不支持 const_iterator。</p><p>我们已经有足够的理由相信应该尽量使用iterator取代const或者reverse类型的迭代器：</p><ul><li><strong>insert和erase的一些版本要求iterator</strong>。如果你需要调用这些函数，你就必须产生iterator，而不能用const或reverse iterators。</li><li><strong>不可能把const_iterator隐式转换成iterator</strong>，我们将会在条款27中讨论从一个const_iterator产生一个iterator的技术并不普遍适用，而且不保证高效。</li><li><strong>从reverse_iterator转换而来的iterator在转换之后可能需要相应的调整</strong>，在条款28中我们会讨论何时需要调整以及调整的原因。</li></ul><h2 id="条款27：用distance和advance把const-iterator转化成iterator"><a href="#条款27：用distance和advance把const-iterator转化成iterator" class="headerlink" title="条款27：用distance和advance把const_iterator转化成iterator"></a>条款27：用distance和advance把const_iterator转化成iterator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> ci = <span class="hljs-keyword">static_cast</span>&lt;vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator&gt;(it);<br><span class="hljs-comment">// auto it2 = static_cast&lt;vector&lt;int&gt;::iterator&gt;(ci);  // 不支持</span><br><br><span class="hljs-keyword">auto</span> it2 = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// advance: increment iterator by offset</span><br><span class="hljs-comment">// distance: find difference of two iterators</span><br><span class="hljs-comment">// 根据距离移动对应的指针</span><br><span class="hljs-comment">// 但是实际运行起来报错了 .... </span><br><span class="hljs-comment">// advance(it2, distance&lt;decltype(ci)&gt;(ci, it2));</span><br><span class="hljs-built_in">advance</span>(it2, ci - it2);<br></code></pre></td></tr></table></figure><h2 id="条款28：了解如何通过reverse-iterator的base得到iterator"><a href="#条款28：了解如何通过reverse-iterator的base得到iterator" class="headerlink" title="条款28：了解如何通过reverse_iterator的base得到iterator"></a>条款28：了解如何通过reverse_iterator的base得到iterator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>cout &lt;&lt; v &lt;&lt; endl;<br><br><span class="hljs-comment">// 插入 ri 时, 插入发生在 ri 指向的正向下一个元素</span><br><span class="hljs-comment">// &#123;0,1,2,3,4,5,6,7,8,9&#125; -&gt; &#123;0,1,2,3,4,5,6, 5 ,7,8,9&#125; </span><br><span class="hljs-keyword">auto</span> ri = v.<span class="hljs-built_in">rbegin</span>() + <span class="hljs-number">3</span>;<br>cout &lt;&lt; *ri &lt;&lt; endl;<br>v.<span class="hljs-built_in">insert</span>(ri.<span class="hljs-built_in">base</span>(), <span class="hljs-number">5</span>);<br>cout &lt;&lt; v &lt;&lt; endl;<br><br><span class="hljs-comment">// 删除 ri 时, 删除发生在 ri 指向的正向下一个元素</span><br><span class="hljs-comment">// &#123;0,1,2,3,4,5,6,5,7,8,9&#125; -&gt; &#123;0,1,2,3,4,5,6,5  ,  8,9&#125; </span><br>ri = v.<span class="hljs-built_in">rbegin</span>() + <span class="hljs-number">3</span>;<br>v.<span class="hljs-built_in">erase</span>(ri.<span class="hljs-built_in">base</span>());<br>cout &lt;&lt; v &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>总结：<code>**ri.base()</code> 永远返回指向 ri 的正向下一个元素<strong>。因此，对于  <strong>逆向的 insert</strong>  来说，插入刚好发生在 ri 的逆向上一个元素；</strong>对于  逆向的 erase  来说，删除刚好发生在 ri 的逆向上一个元素，并不像 iterator 那样删除本身**。</p><h2 id="条款29：需要一个一个字符输入时考虑使用istreambuf-iterator"><a href="#条款29：需要一个一个字符输入时考虑使用istreambuf-iterator" class="headerlink" title="条款29：需要一个一个字符输入时考虑使用istreambuf_iterator"></a>条款29：需要一个一个字符输入时考虑使用istreambuf_iterator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 istream_iterator</span><br><span class="hljs-comment">// 输出: HelloWorld</span><br><span class="hljs-comment">// 35ms</span><br><span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">iic</span><span class="hljs-params">(iss)</span>, eof1</span>;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(iic, eof1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;string read by istream_iterator: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用 istreambuf_iterator</span><br><span class="hljs-comment">// 输出: Hello World</span><br><span class="hljs-comment">// 18ms</span><br><span class="hljs-function">istringstream <span class="hljs-title">iss2</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><span class="hljs-function">istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ibic</span><span class="hljs-params">(iss2)</span>, eof2</span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(ibic, eof2)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;string read by istreambuf_iterator: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>使用 istreambuf_iterator 比 istream_iterator 快了大约一半。</p><p>istream_iterator 使用了 operator&gt;&gt; 来读取输入，因此能够设置<strong>模式化</strong>读入；istream_iterator 使用了 cin.getchar() 读取，所以对于读取单个的字符会更快。</p>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Iterator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 02 - Vector and String</title>
    <link href="/2024/03/17/Vector-and-String/"/>
    <url>/2024/03/17/Vector-and-String/</url>
    
    <content type="html"><![CDATA[<h1 id="Vector-and-String"><a href="#Vector-and-String" class="headerlink" title="Vector and String"></a>Vector and String</h1><h2 id="条款13：尽量使用vector和string来代替动态分配的数组"><a href="#条款13：尽量使用vector和string来代替动态分配的数组" class="headerlink" title="条款13：尽量使用vector和string来代替动态分配的数组"></a>条款13：尽量使用vector和string来代替动态分配的数组</h2><p>无论何时，你发现你自己准备动态分配一个数组（也就是，企图写“new T[…]”），你应该首先考虑使用一个vector或一个string。</p><p>坦白地说，我想到了一个（也是唯一一个）用vector或string代替动态分配数组会出现的问题，而且它只关系到string。<strong>很多string实现在后台使用了引用计数</strong>（参见条款15），一个消除了不必要的内存分配和字符拷贝的策略，而且在很多应用中可以提高性能。事实上，一般认为通过引用计数优化字符串很重要，所以C++标准委员会特别设法保证了那是一个合法的实现。</p><p>唉，一个程序员的优化就是其他人的抱怨，而且如果<strong>你在多线程环境中使用了引用计数的字符串，你可能发现避免分配和拷贝所节省下的时间都花费在后台并发控制上了</strong>。（细节请参考Sutter的文章《Optimizations That Aren’t (In a Multithreaded World)》[20]。）如果你在多线程环境中使用引用计数字符串，就应该注意线程安全性支持所带来的的性能下降问题。</p><h2 id="条款14：使用reserve来避免不必要的重新分配"><a href="#条款14：使用reserve来避免不必要的重新分配" class="headerlink" title="条款14：使用reserve来避免不必要的重新分配"></a>条款14：使用reserve来避免不必要的重新分配</h2><p>如果我们知道、或者能够预测出 vector 的大小，那么就能够使用 reserve 预先申请足够的大小。</p><p>以下是四个与内存分配有关的函数的介绍：</p><ul><li><code>size()</code> 获取到 vector 中元素的数量</li><li><code>capacity()</code> 获取 vector 中<strong>已分配的内存</strong>可以容纳多少元素</li><li><code>resize()</code> 强制将当前容器的大小设置为 n。<ul><li>如果 <code>n &gt; size()</code> ，会销毁元素到 n 个，<code>size()</code> 会返回 n 的大小，<strong>不会影响 <code>capacity()</code> 的大小</strong></li><li>如果 <code>capacity() &gt; n &gt; size()</code> ，会以默认值填充，不影响 capacity</li><li>如果 <code>n &gt; capacity()</code> ，会构造新元素（<strong>按照添加新元素的方法去申请内存</strong>），再填充</li></ul></li><li><code>reserve()</code> 会申请容纳 n 个元素的内存，但是不会影响 size，影响的是 capacity。<code>reserve</code> 应该应用在使用尾插法增加元素的 vector 中，<del>如果完全确定容器的大小，可以使用 <code>resize</code></del> 。<ul><li>如果完全确定容器的大小，应该<strong>先使用 reserve 申请足够的内存，然后使用 resize 改变容器的大小</strong>，这样不会导致额外的内存占用</li></ul></li></ul><p>测试如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);  <span class="hljs-comment">// size=5, capacity=100</span><br>cout &lt;&lt; <span class="hljs-string">&quot;size of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, capacity of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">50</span>);    <span class="hljs-comment">// size=50, capacity=100</span><br>cout &lt;&lt; <span class="hljs-string">&quot;size of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, capacity of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">101</span>);  <br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">101</span>);  <span class="hljs-comment">// size=101, capacity=101</span><br>cout &lt;&lt; <span class="hljs-string">&quot;size of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, capacity of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><span class="hljs-comment">// size=5, capacity=101</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// capacity() 不受影响, 因此才有后面的 shrink</span><br>cout &lt;&lt; <span class="hljs-string">&quot;size of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, capacity of v: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="条款15：小心string实现的多样性"><a href="#条款15：小心string实现的多样性" class="headerlink" title="条款15：小心string实现的多样性"></a>条款15：小心string实现的多样性</h2><p>介绍了 string 的 4 中实现，每种实现由不同的性质，例如可能使用了引用计数（TODO：检查 string 中的引用计数）。</p><p><img src="https://s2.loli.net/2024/03/17/F74PZ1mKkjuQ3ny.png" alt="Untitled.png"></p><p><img src="https://s2.loli.net/2024/03/17/MAIqRYOgZQpKz15.png" alt="Untitled 1.png"></p><p><img src="https://s2.loli.net/2024/03/17/OgBA8QMDzu4J9mK.png" alt="Untitled 2.png"></p><p><img src="https://s2.loli.net/2024/03/17/owQNKpiGcLR5gjI.png" alt="Untitled 3.png"></p><p>总结如下：</p><ul><li>字符串值可能是或可能不是引用计数的。默认情况下，很多实现的确是用了引用计数，但它们通常提供了关闭的方法，一般是通过预处理宏。条款13给了一个你可能要关闭的特殊环境的例子，但你也可能因为其他原因而要那么做。比如，引用计数只对频繁拷贝的字符串有帮助，而有些程序不经常拷贝字符串，所以没有那个开销。</li><li>string对象的大小可能从1到至少7倍char<em>指针的大小。（部分 string 的实现只有一个 char</em> 指针，有些还可能存放了 size、capacity）</li><li>新字符串值的建立可能需要0、1或2次动态分配。</li><li>string对象可能是或可能不共享字符串的大小和容量信息。</li><li>string可能是或可能不支持每对象配置器。</li><li>不同实现对于<strong>最小化字符缓冲区的配置器</strong>有不同策略。（类似 vector 那样的 capacity）</li></ul><h2 id="条款16-如何将vector和string的数据传给遗留的API"><a href="#条款16-如何将vector和string的数据传给遗留的API" class="headerlink" title="条款16: 如何将vector和string的数据传给遗留的API"></a>条款16: 如何将vector和string的数据传给遗留的API</h2><p>vector<T> 代表了 T<em>，而 string 并不一定代表了 char</em>，因为有些 string 的实现可能并不会保留 <code>\0</code> ，因为 string 带有 size 信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取 数组指针</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-built_in">doSth</span>(&amp;v[<span class="hljs-number">0</span>]);<br><br><span class="hljs-comment">// 获取 字符串指针</span><br>string s&#123;<span class="hljs-string">&quot;1234abcd&quot;</span>&#125;;<br><span class="hljs-built_in">doSth</span>(s.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><p>使用数组指针和字符串指针时需要注意：</p><ul><li>不要修改大小，以及在未申请的内存中构造元素</li></ul><p>一个通用的方法是  <strong>构造-拷贝</strong>  ： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(<span class="hljs-type">double</span> *pArray, <span class="hljs-type">size_t</span> arraySize)</span></span>; <span class="hljs-comment">// 同上</span><br><br><span class="hljs-comment">// 如果使用 C API 构造了元素，需要及时 resize</span><br><span class="hljs-comment">// 否则 vector 再也无法知道自己的大小了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">vd</span><span class="hljs-params">(maxNumDoubles)</span></span>; <span class="hljs-comment">// 一样同上</span><br>vd.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">fillArray</span>(&amp;vd[<span class="hljs-number">0</span>], vd.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-function">deque&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(vd.begin(), vd.end())</span></span>; <span class="hljs-comment">// 拷贝数据到deque</span><br><span class="hljs-function">list&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(vd.begin(), vd.end())</span></span>; <span class="hljs-comment">// 拷贝数据到list</span><br><span class="hljs-function">set&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(vd.begin(), vd.end())</span></span>; <span class="hljs-comment">// 拷贝数据到se</span><br></code></pre></td></tr></table></figure><h2 id="条款17：使用“交换技巧”来修整过剩容量"><a href="#条款17：使用“交换技巧”来修整过剩容量" class="headerlink" title="条款17：使用“交换技巧”来修整过剩容量"></a>条款17：使用“交换技巧”来修整过剩容量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-comment">// 使用 shrink_to_fit</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">shrink_to_fit</span>();<br><br><span class="hljs-comment">// 使用 swap 技巧</span><br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);<br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);<br></code></pre></td></tr></table></figure><p>shrink_to_fit：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_CONSTEXPR20 <span class="hljs-type">void</span> <span class="hljs-title">shrink_to_fit</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// reduce capacity to size, provide strong guarantee</span><br>    <span class="hljs-keyword">auto</span>&amp; _My_data         = _Mypair._Myval2;<br>    <span class="hljs-type">const</span> pointer _Oldlast = _My_data._Mylast;<br>    <span class="hljs-keyword">if</span> (_Oldlast != _My_data._Myend) &#123; <span class="hljs-comment">// something to do</span><br>        <span class="hljs-type">const</span> pointer _Oldfirst = _My_data._Myfirst;<br>        <span class="hljs-keyword">if</span> (_Oldfirst == _Oldlast) &#123;  <span class="hljs-comment">// 如果数组为空, 释放所有内存</span><br>            _Tidy();<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则重新分配</span><br>            _Reallocate_exactly(<span class="hljs-built_in">static_cast</span>&lt;size_type&gt;(_Oldlast - _Oldfirst));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款18：避免使用vector"><a href="#条款18：避免使用vector" class="headerlink" title="条款18：避免使用vector"></a>条款18：避免使用vector<bool></h2><p><strong>作为一个 vector<bool>，它既不 vector，也不 bool。</strong></p><p>vector<bool> 的实现是一个位域，即一个字节，包含了 8 个 bool。所以，<strong>无法得到 vector<bool> 的元素的指针</strong>。只能得到一个 代理对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// reference 不是真正的指针, 只是一个 “代理对象”</span><br>vector&lt;<span class="hljs-type">bool</span>&gt;::reference<br></code></pre></td></tr></table></figure><p>在 MSVC 的实现中，<code>vector&lt;bool&gt;</code> 做了<strong>额外的模板特化</strong>。</p><p>如果需要使用 vector<bool>，可以使用 deque<bool> 或者 bitset<N> 。vector<bool>不满足STL容器的必要条件，你最好不要使用它；而deque<bool>和bitset是基本能满足你对vector<bool>提供的性能的需要的替代数据结构。</p><h2 id="条款19：了解相等和等价的区别"><a href="#条款19：了解相等和等价的区别" class="headerlink" title="条款19：了解相等和等价的区别"></a>条款19：了解相等和等价的区别</h2><table><thead><tr><th>相等</th><th>等价</th></tr></thead><tbody><tr><td>operator&#x3D;&#x3D;(lhs, rhs)</td><td>!(lhs &lt; rhs) &amp;&amp; !(rhs &lt; lhs)</td></tr><tr><td>&#x3D;&#x3D; 返回 True</td><td>两个对象  互相不大于  对方</td></tr></tbody></table><p>一些函数对于相等和等价的要求不同：</p><ul><li>find 函数是基于相等的</li><li><strong>sort、标准关联容器（set、map、multiset、multimap）以及多种基于比较的标准函数</strong>，都是基于等价的。</li></ul><h2 id="条款20：为指针的关联容器指定比较类型"><a href="#条款20：为指针的关联容器指定比较类型" class="headerlink" title="条款20：为指针的关联容器指定比较类型"></a>条款20：为指针的关联容器指定比较类型</h2><p>指针的关联容器只会比较指针的值，即对指针的 <code>size_t</code> 排序，而不是对 <code>*T</code> 进行排序。对于普通指针和只能指针，都需要手动提供一个比较类型</p><h2 id="条款21-永远让比较函数对相等的值返回false"><a href="#条款21-永远让比较函数对相等的值返回false" class="headerlink" title="条款21: 永远让比较函数对相等的值返回false"></a>条款21: 永远让比较函数对相等的值返回false</h2><p>你所要记住的就是<strong>比较函数的返回值表明的是在此函数定义的排序方式下，一个值是否大于另一个</strong>。相等的值绝不该一个大于另一个，所以比较函数总应该对相等的值返回false。</p><p>如果发生了小于等于，程序会直接报错（segment fault）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 错误</span><br>[] (<span class="hljs-type">int</span>&amp; lhs, <span class="hljs-type">int</span>&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs &lt;= rhs;<br>&#125;<br><br><span class="hljs-comment">// 正确</span><br>[] (<span class="hljs-type">int</span>&amp; lhs, <span class="hljs-type">int</span>&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs &lt; rhs;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort 的手动实现可以查看 <a href="https://www.notion.so/35c2fc0b73a440d68b8cd3c4c065b088?pvs=21">排序</a> ，在这个实现中，如果使用了小于等于，会存在<strong>变量的排序位置错误</strong>。</p><h2 id="条款22：避免原地修改set和multiset的键"><a href="#条款22：避免原地修改set和multiset的键" class="headerlink" title="条款22：避免原地修改set和multiset的键"></a>条款22：避免原地修改set和multiset的键</h2><p>set 的声明：<code>set&lt;T&gt;</code> ，map 的声明：<code>map&lt;const K, V&gt;</code> ，因此，map 的 key 是无法被修改的，但是 set 的 key 是可以被修改的。<strong>修改了 set 的 key 之后会导致 set 内部的有序性被破坏</strong>，容器再也不是一个 set 了。</p><p>为什么 set 是 T 而不是 const T？</p><p>因为自定义的 <code>operator&lt;()</code> 函数可能只使用到了类中的部分成员，举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IDNumberLess</span>&#123;<br> <span class="hljs-keyword">public</span> binary_function&lt;Employee, Employee, <span class="hljs-type">bool</span>&gt; &#123; <span class="hljs-comment">// 参见条款40</span><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Employees lhs,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> Employee&amp; rhs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">idNumber</span>() &lt; rhs.<span class="hljs-built_in">idNumber</span>();<br> &#125;<br>&#125;;<br><span class="hljs-keyword">typedef</span> set&lt;Employee, IDNumberLess&gt; EmpIDSet;<br>EmpIDSet se; <span class="hljs-comment">// se是雇员的set，</span><br> <span class="hljs-comment">// 按照ID号排序</span><br></code></pre></td></tr></table></figure><p>如果你要总是可以工作而且总是安全地改变set、multiset、map或multimap里的元素，按五个简单的步骤去做：</p><ol><li>定位你想要改变的容器元素。如果你不确定最好的方法，条款45提供了关于怎样进行适当搜寻的指导。</li><li>拷贝一份要被修改的元素。对map或multimap而言，确定不要把副本的第一个元素声明为const。毕竟，你想要改变它！</li><li>修改副本，使它有你想要在容器里的值。</li><li>从容器里删除元素，通常通过调用erase（参见条款9）。</li><li>把新值插入容器。如果新元素在容器的排序顺序中的位置正好相同或相邻于删除的元素，<strong>使用insert的“提示”形式把插入的效率从对数时间改进到分摊的常数时间</strong>。使用你从第一步获得的迭代器作为提示。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">// 删除一个 key, 并在重新插入时 给定 hint</span><br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// s.erase(it++);          // 自增迭代器, 以确保迭代器有效</span><br>it = s.<span class="hljs-built_in">erase</span>(it);    <span class="hljs-comment">// 更新迭代器, 以确保迭代器有效</span><br>s.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>MSVC 的实现就是一个 <code>set&lt;const T&gt;</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; sp = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>for_each(sp.<span class="hljs-built_in">begin</span>(), sp.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; p) &#123;  <span class="hljs-comment">// 必须是 const 或者 auto</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;&lt;&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;&gt;, &quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="条款23：考虑用有序vector代替关联容器"><a href="#条款23：考虑用有序vector代替关联容器" class="headerlink" title="条款23：考虑用有序vector代替关联容器"></a>条款23：考虑用有序vector代替关联容器</h2><p>因为 关联容器 的内部保存了一个有序的结构，因此 <strong>一个有序的 vector</strong> 能够用于替代关联容器。使用有序 vector 代替关联容器的关键在于：</p><ul><li>vector 的插入和删除较少，或者没有。因为移动会带来大量的数据拷贝。</li><li>对于查找操作，可以使用 binary_search、lower_bound 等</li><li>有序 vector 比关联容器更优秀的地方在于：<ul><li>内存局部性更高</li><li>减少了指针，内存页能够容纳的数据更多</li></ul></li></ul><h2 id="条款24：当关乎效率时应该在map-operator-和map-insert之间仔细选择"><a href="#条款24：当关乎效率时应该在map-operator-和map-insert之间仔细选择" class="headerlink" title="条款24：当关乎效率时应该在map::operator[]和map-insert之间仔细选择"></a>条款24：当关乎效率时应该在map::operator[]和map-insert之间仔细选择</h2><p>这项工作的原理是<strong>operator[]返回一个与k关联的值对象的引用</strong>。然后v赋值给所引用（从operator[]返回的）的对象。当要更新一个已存在的键的关联值时很直接，因为已经有operator[]可以用来返回引用的值对象。但是如果k还不在map里，operator[]就没有可以引用的值对象。那样的话，它使用值类型的默认构造函数从头开始建立一个，然后operator[]返回这个新建立对象的引用。</p><p>因此出于对效率的考虑，当给map<strong>添加一个元素时，我们断定insert比operator[]好</strong>；而从效率和美学考虑，<strong>当更新已经在map里的元素值时operator[]更好</strong>。</p><p>如下是一个结合 insert 和 operator[] 的函数，能够结合二者的好处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br>map&lt;K,V&gt;::<span class="hljs-function">iterator <span class="hljs-title">dynamicInsert</span><span class="hljs-params">(map&lt;K, V&gt;&amp; s, K k, V v)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到  距离 k 最近的元素</span><br>    <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(k);<br>    <span class="hljs-keyword">if</span> (it-&gt;first == k) &#123;<br>        <span class="hljs-comment">// 更新元素</span><br>        it-&gt;second = v;<br>        <span class="hljs-keyword">return</span> it;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 插入元素, 注意插入时会返回新元素的迭代器</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(it, &#123;k, v&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款25：熟悉非标准散列容器"><a href="#条款25：熟悉非标准散列容器" class="headerlink" title="条款25：熟悉非标准散列容器"></a>条款25：熟悉非标准散列容器</h2><p>在C++标准委员会的议案中，散列容器的名字是unordered_set、unordered_multiset、unordered_map和unordered_multimap。恰好是为了避开现存的hash_*名字。</p><p>哈希冲突的解决方案：开放地址法、拉链法。</p>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>Vector</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL - 01 - Containers</title>
    <link href="/2024/03/17/Containers/"/>
    <url>/2024/03/17/Containers/</url>
    
    <content type="html"><![CDATA[<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><h2 id="条款-1-仔细选择你的容器"><a href="#条款-1-仔细选择你的容器" class="headerlink" title="条款 1 仔细选择你的容器"></a>条款 1 仔细选择你的容器</h2><blockquote><p>vector是一种可以默认使用的序列类型，当很频繁地对序列中部进行插入和删除时应该用list，当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构</p></blockquote><blockquote><p>连续内存容器（也叫做基于数组的容器）在一个或多个（动态分配）的内存块中保存它们的元素。<strong>如果一个新元素被查入或者已存元素被删除，其他在同一个内存块的元素就必须向上或者向下移动来为新元素提供空间或者填充原来被删除的元素所占的空间</strong>。这种移动影响了效率（参见条款5和14）和异常安全（就像我们将会看到的）。标准的连续内存容器是vector、string和deque。</p></blockquote><blockquote><p><strong>基于节点的容器在每个内存块（动态分配）中只保存一个元素</strong>。容器元素的插入或删除只影响指向节点的指针，而不是节点自己的内容。</p></blockquote><blockquote><p>你要把迭代器、指针和引用的失效次数减到最少吗？如果是，你就应该使用基于节点的容器，因为在这些容器上进行插入和删除不会使迭代器、指针和引用失效（除非它们指向你删除的元素）。<strong>一般来说，在连续内存容器上插入和删除会使所有指向容器的迭代器、指针和引用失效</strong>。</p></blockquote><blockquote><p>你需要具有有以下特性的序列容器吗：1）可以使用随机访问迭代器；2）只要没有删除而且插入只发生在容器结尾，指针和引用的数据就不会失效？这个一个非常特殊的情况，但如果你遇到这种情况，deque就是你梦想的容器。（有趣的是，当插入只在容器结尾时，deque的迭代器也可能会失效，deque是唯一一个“在迭代器失效时不会使它的指针和引用失效”的标准STL容器。）</p></blockquote><p>在 vector 上会插入和删除会导致当前的迭代器失效。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; *it &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br><br>v.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">-1</span>);<br>cout &lt;&lt; *it &lt;&lt; endl;  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>TODO：对应容器的失效规则。</p><h2 id="条款2：小心对“容器无关代码”的幻想"><a href="#条款2：小心对“容器无关代码”的幻想" class="headerlink" title="条款2：小心对“容器无关代码”的幻想"></a>条款2：小心对“容器无关代码”的幻想</h2><blockquote><p>标准的内存相邻容器（参见条款1）都提供随机访问迭代器，标准的基于节点的容器（再参见条款1）都提供双向迭代器。序列容器支持push_front或push_back，但关联容器不支持。关联容器提供对数时间复杂度的lower_bound、upper_bound和equal_range成员函数，但序列容器却没有。</p></blockquote><blockquote><p>在一个序列容器上用一个迭代器作为参数调用erase，会返回一个新迭代器，但在关联容器上什么都不返回。</p></blockquote><p>既然有了要一次次的改变容器类型的必然性，你可以用这个常用的方法让改变得以简化：使用封装，封装，再封装。其中一种最简单的方法是通过自由地对容器和迭代器类型使用typedef。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;...&#125;;<br>vector&lt;Widget&gt; vw;<br>Widget bestWidget;<br>... <span class="hljs-comment">// 给bestWidget一个值</span><br>vector&lt;Widget&gt;::iterator i = <span class="hljs-comment">// 寻找和bestWidget相等的Widget</span><br> <span class="hljs-built_in">find</span>(vw.<span class="hljs-built_in">begin</span>(), vw.<span class="hljs-built_in">end</span>(), bestWidget);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; ... &#125;;<br><span class="hljs-keyword">typedef</span> vector&lt;Widget&gt; WidgetContainer;<br><span class="hljs-keyword">typedef</span> WidgetContainer::iterator WCIterator;<br>WidgetContainer cw;<br>Widget bestWidget;<br>...<br>WCIterator i = <span class="hljs-built_in">find</span>(cw.<span class="hljs-built_in">begin</span>(), cw.<span class="hljs-built_in">end</span>(), bestWidget);<br></code></pre></td></tr></table></figure><p>如果你不想暴露出用户对你所决定使用的容器的类型，你需要更大的火力，那就是class。</p><p>目前有了 auto 操作，大部分 typedef 应该是可以省略的。</p><h2 id="条款3：使容器里对象的拷贝操作轻量而正确"><a href="#条款3：使容器里对象的拷贝操作轻量而正确" class="headerlink" title="条款3：使容器里对象的拷贝操作轻量而正确"></a>条款3：使容器里对象的拷贝操作轻量而正确</h2><p>一旦一个对象进入一个容器，以后对它的拷贝并不少见。如果你从vector、string或deque中<strong>插入或删除</strong>了什么，现有的容器元素会移动（拷贝）（参见条款5和14）。如果你使用了任何<strong>排序算法</strong>（参见条款31）：next_permutation或者previous_permutation；remove、unique或它们的同类（参见条款32）；rotate或reverse等，对象会移动（拷贝）。是的，拷贝对象是STL的方式。</p><blockquote><p>一个使拷贝更高效、正确而且对分割问题免疫的简单的方式是<strong>建立指针的容器</strong>而不是对象的容器。</p><p><em>所以，对于 容器 来说，大部分都只是保存一个 <code>T*</code> ，而不是数组</em></p></blockquote><p>和数组对比，STL容器更文明。它们只建立（通过拷贝）你需要的个数的对象，而且它们只在你指定的时候做。是的，我们需要知道STL容器使用了拷贝，但是别忘了一个事实：比起数组它们仍然是一个进步。</p><h2 id="条款4：用empty来代替检查size-是否为0"><a href="#条款4：用empty来代替检查size-是否为0" class="headerlink" title="条款4：用empty来代替检查size()是否为0"></a>条款4：用empty来代替检查size()是否为0</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; list1; <br>list&lt;<span class="hljs-type">int</span>&gt; list2; <br>... <br>list1.<span class="hljs-built_in">splice</span>( <span class="hljs-comment">// 把list2中</span><br> list1.<span class="hljs-built_in">end</span>(), list2, <span class="hljs-comment">// 从第一次出现5到</span><br> <span class="hljs-built_in">find</span>(list2.<span class="hljs-built_in">begin</span>(), list2.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>), <span class="hljs-comment">// 最后一次出现10</span><br> <span class="hljs-built_in">find</span>(list2.<span class="hljs-built_in">rbegin</span>(), list2.<span class="hljs-built_in">rend</span>(), <span class="hljs-number">10</span>).<span class="hljs-built_in">base</span>() <span class="hljs-comment">// 的所有节点移到list1的结尾。</span><br>); <span class="hljs-comment">// 关于调用的</span><br> <span class="hljs-comment">// &quot;base()&quot;的信息，请参见条款28</span><br></code></pre></td></tr></table></figure><p>考虑这部分代码。（其中 splice 是拼接，接合，即把两个 list 合并。上述代码的意思是：在 list1 的末尾，拷贝从 list2 第一次出现 5，到最后一次出现 10 的所有数据）</p><p>常数时间的 splice 与常数时间的 size 是相违背的，即：</p><ol><li>如果 splice 是常数时间，那么无法在 splice 的过程中更新 size，那么每次调用 size 时就必须以 O(N) 的方式遍历</li><li>如果 size 是常数时间，那么 splice 必须更新 size，splice 就会是 O(N)</li></ol><p>因此，调用 <code>empty()</code> 可以获得更好的时间复杂度，因为它总是 O(1) 的</p><h2 id="条款5：尽量使用区间成员函数代替它们的单元素兄弟"><a href="#条款5：尽量使用区间成员函数代替它们的单元素兄弟" class="headerlink" title="条款5：尽量使用区间成员函数代替它们的单元素兄弟"></a>条款5：尽量使用区间成员函数代替它们的单元素兄弟</h2><p>区间成员函数指的是使用 range 的成员函数，使用一个开头迭代器，一个结尾迭代器标识区间。然后根据不同的操作，有不同的变化。单元素兄弟，就是直接访问数据。</p><p>区间成员函数 和 单元素兄弟 写法的对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v1, v2;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 单元素写法</span><br>v1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; it != v2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>  v1.<span class="hljs-built_in">push_back</span>(*it);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">insertLoc</span><span class="hljs-params">(v1.begin())</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br> insertLoc = v1.<span class="hljs-built_in">insert</span>(insertLoc, data[i]);<br> ++insertLoc;  <span class="hljs-comment">// 迭代器失效, 必须更新</span><br>&#125;<br><br><span class="hljs-comment">// 区间成员函数写法</span><br>v1.<span class="hljs-built_in">assgin</span>(v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>());<br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">copy</span>(v2.<span class="hljs-built_in">begin</span>() + v2.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>, v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(v1. v1.<span class="hljs-built_in">end</span>()));<br><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), data, data + numValues);<br></code></pre></td></tr></table></figure><p>copy 仍然比写 assign 的调用要做更多的工作。此外，虽然在这段代码中没有表现出循环，在copy中的确存在一个循环(参见条款43）。结果，效率损失仍然存在。我也会在下面讨论。在这里，我要离题一下来指出几乎所有目标区间是通过插入迭代器（比如，通过inserter，back_inserter或front_inserter）指定的copy的使用都可以——应该——通过调用区间成员函数来代替。</p><p>本条款的主题：<strong>几乎所有目标区间被插入迭代器指定的copy的使用都可以用调用的区间成员函数的来代替</strong>。</p><p>原因：1、减少函数调用；2、数据移动的开销（单元素每次都要移动一次数组，区间可以直接移动到最终位置，<strong>减少了 N - 1 次的 移动&#x2F;拷贝 开销</strong>）；3、vector 扩容机制。</p><p>支持区间成员函数的写法：</p><ul><li>构造函数：<code>Container::Container(InputIterator begin, OutputIterator end);</code></li><li>插入：<ul><li>序列容器需要指定插入位置： <code>void Container::insert(iterator position, InputIterator begin, InputIterator end);</code></li><li>关联容器由于是通过比较元素的大小来决定插入位置的，所以不需要插入位置： <code>void Container::insert(InputIterator begin, InputIterator end);</code></li></ul></li><li>删除：<ul><li>序列容器由于迭代器失效，因此会返回一个迭代器： <code>iterator Container::erase(iterator begin, iterator end);</code></li><li>关联容器不会返回（是因为返回会导致不必要的性能开销？）：  <code>void Container::erase(iterator begin, iterator end);</code></li></ul></li><li>赋值：<ul><li><code>void Container::assign(InputIterator begin, InputIterator end);</code></li></ul></li></ul><h2 id="条款6：警惕C-最令人恼怒的解析"><a href="#条款6：警惕C-最令人恼怒的解析" class="headerlink" title="条款6：警惕C++最令人恼怒的解析"></a>条款6：警惕C++最令人恼怒的解析</h2><p>C++ 中会首先解析函数，因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 被解析为一个函数</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lFunc</span><span class="hljs-params">(istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss), istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br><br><span class="hljs-comment">// 被成功解析</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">((istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss)), istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br>for_each(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>第一个变量的定义被解析为一个单纯的函数声明，但是第二个定义被解析为变量定义。（通过添加一个括号的形式，但是这样可能导致 <em>未来的编译器</em> 报错）</p><p>还有另一种不使用匿名对象的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dataBegin</span><span class="hljs-params">(iss)</span>, <span class="hljs-title">dataEnd</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(dataBegin, dataEnd)</span></span>;<br></code></pre></td></tr></table></figure><p>缺点就是不够符合 C++ STL 的风格。</p><h2 id="条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针"><a href="#条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针" class="headerlink" title="条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针"></a>条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针</h2><p>当一个指针的容器被销毁时，会销毁它（那个容器）包含的每个元素，但指针的“析构函数”是无操作！它肯定不会调用delete。即，<strong>只回收了指针占用的内存，而没有回收指针指向的内容占用的内存</strong>。因此，对于  指针的容器，我们需要手动 delete 回收。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSth</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>*&gt; vi;<br>    vi.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10&#x27;000&#x27;000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10&#x27;000&#x27;000</span>; i++)  vi.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">12</span>&#125;);<br>    <span class="hljs-comment">// 回收内存之后, 没有内存泄漏</span><br>    for_each(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>*&amp; a) &#123; <span class="hljs-keyword">delete</span> a; &#125;);  <br>&#125;<br><br><span class="hljs-comment">// 使用智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSthSmart</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vui;<br>    vui.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10&#x27;000&#x27;000</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10&#x27;000&#x27;000</span>; i++)  vui.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">12</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">doSth</span>();            <span class="hljs-comment">// 内存泄漏 6129 MB</span><br>        <span class="hljs-comment">// doSthSmart();    // 无泄漏 4.2 MB</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面还使用仿函数，构建了一个自动回收内存的仿函数类。</p><h2 id="条款8：永不建立auto-ptr的容器"><a href="#条款8：永不建立auto-ptr的容器" class="headerlink" title="条款8：永不建立auto_ptr的容器"></a>条款8：永不建立auto_ptr的容器</h2><p>auto_ptr 不可移植，并且  <strong>对 auto_ptr 的拷贝会改变它本身的值</strong>。</p><h2 id="条款9：在删除选项中仔细选择"><a href="#条款9：在删除选项中仔细选择" class="headerlink" title="条款9：在删除选项中仔细选择"></a>条款9：在删除选项中仔细选择</h2><p>如何选择一个合适的删除选项？分情况讨论如下：</p><ul><li>去除一个容器中有特定值的所有对象：<ul><li>如果容器是vector、string或deque，使用erase-remove惯用法</li><li>如果容器是list，使用list::remove</li><li>如果容器是标准关联容器，使用它的erase成员函数。</li></ul></li><li>去除一个容器中满足一个特定判定式的所有对象：<ul><li>如果容器是vector、string或deque，使用erase-remove_if惯用法。</li><li>如果容器是list，使用list::remove_if。</li><li>如果容器是标准关联容器，使用remove_copy_if和swap，或写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</li></ul></li><li>在循环内做某些事情（除了删除对象之外）：<ul><li>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。</li><li>如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 必须加上这部分 `class...`</span><br><span class="hljs-comment">// 因为 vector 的实际签名是 vector&lt;T, _Allocator&lt;T&gt;&gt;</span><br><span class="hljs-comment">// 不能只加入一个 template parameter</span><br><span class="hljs-comment">// 由于 cout 中似乎无法添加 constant</span><br><span class="hljs-comment">// 因此必须自己建一个类, 来让 C++ 完成类型推导</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>...&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>, <span class="hljs-keyword">typename</span>... T&gt;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, Container&lt;T...&gt;&amp; c) &#123;<br>    <span class="hljs-keyword">using</span> ValueType = <span class="hljs-keyword">typename</span> Container&lt;T...&gt;::value_type;<br>    for_each(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), [&amp;os] (<span class="hljs-type">const</span> ValueType&amp; t) &#123;<br>        os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    list&lt;<span class="hljs-type">int</span>&gt; l&#123;v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()&#125;;<br>    set&lt;<span class="hljs-type">int</span>&gt; s&#123;v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()&#125;;<br><br>    <span class="hljs-comment">// 删除某一个数值</span><br>    <span class="hljs-comment">// vector 使用 erase-remove 技术</span><br>    <span class="hljs-type">int</span> toBeRemoved = <span class="hljs-number">1</span>;<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), toBeRemoved), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// list 使用 remove</span><br>    l.<span class="hljs-built_in">remove</span>(toBeRemoved);<br><br>    <span class="hljs-comment">// set 使用 erase</span><br>    s.<span class="hljs-built_in">erase</span>(toBeRemoved);<br><br>    <span class="hljs-comment">// ===============</span><br>    <span class="hljs-comment">// 条件删除</span><br><br>    <span class="hljs-comment">// vector 使用 erase-remove_if 技术</span><br>    <span class="hljs-type">int</span> upperBound = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">auto</span> pred = [&amp;] (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a) &#123; <span class="hljs-keyword">return</span> a &lt;= upperBound; &#125;;<br><br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), pred), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// list 使用 remove_if</span><br>    l.<span class="hljs-built_in">remove_if</span>(pred);<br><br>    <span class="hljs-comment">// set 使用 remove_copy_if-swap 技术</span><br>    set&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-comment">// 可以使用 inserter(tmp, tmp.end())</span><br>    <span class="hljs-comment">// 不能使用 back_inserter(tmp), 它会调用 push_back 方法</span><br>    <span class="hljs-comment">// 导致 set 容器报错</span><br>    <span class="hljs-comment">// 这里报错很奇怪, 报错的地方在 `set&lt;in&gt;s` 中, 而不是调用的地方</span><br>    <span class="hljs-built_in">remove_copy_if</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(tmp, tmp.<span class="hljs-built_in">end</span>()), pred);<br>    s.<span class="hljs-built_in">swap</span>(tmp);<br><br>    <span class="hljs-comment">// ===============</span><br>    <span class="hljs-comment">// 删除的过程中执行操作</span><br><br>    <span class="hljs-comment">// 序列容器  ---  需要更新 迭代器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>();) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pred</span>(*it)) &#123;<br>            <span class="hljs-comment">// 此时已经更新了 迭代器, 因此不需要 ++</span><br>            it = v.<span class="hljs-built_in">erase</span>(it);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对于不满足条件的值, 直接 ++</span><br>            it++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// set 使用 for 循环  ---  需要及时更新 迭代器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ) &#123;<br>        <span class="hljs-comment">// 对于所有非法的值, 删除之后再移动迭代器到下一个位置</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pred</span>(*it))  s.<span class="hljs-built_in">erase</span>(it++);<br>        <span class="hljs-comment">// 合法的值, 直接移动即可</span><br>        <span class="hljs-keyword">else</span>  it++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款10：注意分配器的协定和约束"><a href="#条款10：注意分配器的协定和约束" class="headerlink" title="条款10：注意分配器的协定和约束"></a>条款10：注意分配器的协定和约束</h2><p>因此，如果你想要写自定义分配器，让我们总结你需要记得的事情。</p><ul><li>把你的分配器做成一个模板，带有模板参数T，代表你要分配内存的对象类型。</li><li>提供pointer和reference的typedef，但是总是让pointer是T*，reference是T&amp;。</li><li>决不要给你的分配器添加对象状态。通常，分配器不能有非静态的数据成员。</li><li>记得应该传给分配器的<strong>allocate成员函数需要分配的对象个数而不是字节数</strong>。也应该记得<strong>这些函数返回T*指针（通过pointer typedef），即使还没有T对象被构造</strong>。</li><li>一定要提供标准容器依赖的内嵌rebind模板。</li></ul><p>为什么不能添加对象状态？因为编译器认为两个相同的类型的分配器，总是相同的。因此分配器只能拥有静态成员。</p><p>为什么需要 rebind？因为对于基于节点的容器（如 list、set、map 等），他们需要的数据结构是 <code>Node&lt;T&gt;</code> ，而不是 <code>T</code> 。为了分配节点的内存，因此提出了 rebind。通过 rebind 分配这部分的节点内存，rebind 的签名也变成了 <code>allocator&lt;T&gt;::rebind&lt;Node&lt;T&gt;&gt;::other</code> ，其中的 other 就是 <code>&lt;Node&lt;T&gt;</code> 。</p><p>MSVC 的 allocator 实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_INLINE_VAR <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> _Asan_granularity = <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">static_assert</span>(!is_const_v&lt;_Ty&gt;, <span class="hljs-string">&quot;The C++ Standard forbids containers of const elements &quot;</span><br>                                    <span class="hljs-string">&quot;because allocator&lt;const T&gt; is ill-formed.&quot;</span>);<br><br>    <span class="hljs-keyword">using</span> _From_primary = allocator;<br><br>    <span class="hljs-keyword">using</span> value_type = _Ty;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    <span class="hljs-keyword">using</span> pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty*;<br>    <span class="hljs-keyword">using</span> const_pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = <span class="hljs-type">const</span> _Ty*;<br><br>    <span class="hljs-keyword">using</span> reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty&amp;;<br>    <span class="hljs-keyword">using</span> const_reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = <span class="hljs-type">const</span> _Ty&amp;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-keyword">using</span> size_type       = <span class="hljs-type">size_t</span>;<br>    <span class="hljs-keyword">using</span> difference_type = <span class="hljs-type">ptrdiff_t</span>;<br><br>    <span class="hljs-keyword">using</span> propagate_on_container_move_assignment           = true_type;<br>    <span class="hljs-keyword">using</span> is_always_equal _CXX20_DEPRECATE_IS_ALWAYS_EQUAL = true_type;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    <span class="hljs-comment">// rebind 的实现</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Other</span>&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS</span> rebind &#123;<br>        <span class="hljs-keyword">using</span> other = allocator&lt;_Other&gt;;<br>    &#125;;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD _Ty* <span class="hljs-title">address</span><span class="hljs-params">(_Ty&amp; _Val)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _STD <span class="hljs-built_in">addressof</span>(_Val);<br>    &#125;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD <span class="hljs-type">const</span> _Ty* <span class="hljs-title">address</span><span class="hljs-params">(<span class="hljs-type">const</span> _Ty&amp; _Val)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _STD <span class="hljs-built_in">addressof</span>(_Val);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 分配内存 或者 rebind 的内存</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">(<span class="hljs-type">const</span> allocator&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>= <span class="hljs-keyword">default</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Other</span>&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">allocator</span><span class="hljs-params">(<span class="hljs-type">const</span> allocator&lt;_Other&gt;&amp;)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br>    _CONSTEXPR20 ~<span class="hljs-built_in">allocator</span>()                           = <span class="hljs-keyword">default</span>;<br>    _CONSTEXPR20 allocator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> allocator&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">_CONSTEXPR20 <span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(_Ty* <span class="hljs-type">const</span> _Ptr, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        _STL_ASSERT(_Ptr != <span class="hljs-literal">nullptr</span> || _Count == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;null pointer cannot point to a block of non-zero size&quot;</span>);<br>        <span class="hljs-comment">// no overflow check on the following multiply; we assume _Allocate did that check</span><br>        _Deallocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Ptr, <span class="hljs-built_in">sizeof</span>(_Ty) * _Count);<br>    &#125;<br><br>    _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) <span class="hljs-function">_Ty* <span class="hljs-title">allocate</span><span class="hljs-params">(_CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(value_type) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;value_type must be complete before calling allocate.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty*&gt;(_Allocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Get_size_of_n&lt;<span class="hljs-built_in">sizeof</span>(_Ty)&gt;(_Count)));<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_CXX23</span><br>    <span class="hljs-function">_NODISCARD_RAW_PTR_ALLOC <span class="hljs-keyword">constexpr</span> allocation_result&lt;_Ty*&gt; <span class="hljs-title">allocate_at_least</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">allocate</span>(_Count), _Count&#125;;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_CXX23</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span><br>    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) <span class="hljs-function">_Ty* <span class="hljs-title">allocate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _CRT_GUARDOVERFLOW <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> _Count, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">allocate</span>(_Count);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Objty</span>, <span class="hljs-keyword">class</span>... _Types&gt;<br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS <span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(_Objty* <span class="hljs-type">const</span> _Ptr, _Types&amp;&amp;... _Args)</span> </span>&#123;<br>        ::<span class="hljs-keyword">new</span> (_Voidify_iter(_Ptr)) _Objty(_STD forward&lt;_Types&gt;(_Args)...);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Uty</span>&gt;<br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(_Uty* <span class="hljs-type">const</span> _Ptr)</span> </span>&#123;<br>        _Ptr-&gt;~_Uty();<br>    &#125;<br><br>    <span class="hljs-function">_CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD <span class="hljs-type">size_t</span> <span class="hljs-title">max_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">-1</span>) / <span class="hljs-built_in">sizeof</span>(_Ty);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _HAS_DEPRECATED_ALLOCATOR_MEMBERS</span></span><br><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> _Minimum_allocation_alignment = _Asan_granularity;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款11：理解自定义分配器的正确用法"><a href="#条款11：理解自定义分配器的正确用法" class="headerlink" title="条款11：理解自定义分配器的正确用法"></a>条款11：理解自定义分配器的正确用法</h2><p>自定义前提：</p><ul><li>你用了<strong>基准测试，性能剖析</strong>，而且实验了你的方法得到默认的STL内存管理器（即allocator <T>）在你的STL需求中太慢、浪费内存或造成过度的碎片的结论，并且你肯定你自己能做得比它好。</li><li>或者你发现allocator<T>对线程安全采取了措拖，但是你只对<strong>单线程的程序</strong>感兴趣，你不想花费你不需要的同步开销。</li><li>或者你知道在<strong>某些容器里的对象通常一同被使用</strong>，所以你想在一个特别的堆里把它们放得很近使引用的区域性最大化。（hint，提高局部性）</li><li>或者你想建立一个<strong>相当共享内存的唯一的堆</strong>，然后把一个或多个容器放在那块内存里，因为这样它们可以被其他进程共享。</li></ul><p>一个自定义 allocator 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">本文的例子是创建一个在  共享内存区  的对象, malloc 分配的内存在堆区</span><br><span class="hljs-comment">共享内存区 主要跟 多线程/多进程 有关, Linux 中由 SharedMemory 决定</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">makeShared</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeShared</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocator</span> &#123;<br>    <span class="hljs-keyword">using</span> pointer = T*;<br>    <span class="hljs-keyword">using</span> const_pointer = <span class="hljs-type">const</span> T*;<br>    <span class="hljs-keyword">using</span> reference = T&amp;;<br>    <span class="hljs-keyword">using</span> const_reference = <span class="hljs-type">const</span> T&amp;;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br>    <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br><br>    <span class="hljs-function">pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> numObjects, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *localityHint = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">makeShared</span>(numObjects * <span class="hljs-built_in">sizeof</span>(T));<br>        <span class="hljs-comment">// print message and allocate memory with global new</span><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;allocate &quot;</span> &lt;&lt; numObjects &lt;&lt; <span class="hljs-string">&quot; element(s)&quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot; of size &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T) <br>            &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;pointer&gt;(ptr);<br>    &#125;<br><br>    <span class="hljs-comment">// initialize elements of allocated storage p with value value</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span> <span class="hljs-params">(pointer p, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-comment">// initialize memory with placement new</span><br>        <span class="hljs-keyword">new</span>((<span class="hljs-type">void</span>*)p)<span class="hljs-built_in">T</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// destroy elements of initialized storage p</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span> <span class="hljs-params">(pointer p)</span> </span>&#123;<br>        <span class="hljs-comment">// destroy objects by calling their destructor</span><br>        p-&gt;~<span class="hljs-built_in">T</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(pointer dataPtr, <span class="hljs-type">size_t</span> numObjects)</span> </span>&#123;<br>        <span class="hljs-comment">// print message and deallocate memory with global delete</span><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;deallocate &quot;</span> &lt;&lt; numObjects &lt;&lt; <span class="hljs-string">&quot; element(s)&quot;</span><br>                    &lt;&lt; <span class="hljs-string">&quot; of size &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T)<br>                    &lt;&lt; <span class="hljs-string">&quot; at: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)dataPtr &lt;&lt; std::endl;<br>        <span class="hljs-built_in">freeShared</span>(dataPtr);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123;<br>        <span class="hljs-keyword">using</span> other = MyAllocator&lt;U&gt;;<br>    &#125;;<br><br>    <span class="hljs-comment">// return address of values</span><br>    <span class="hljs-function">pointer <span class="hljs-title">address</span> <span class="hljs-params">(reference value)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;value; &#125;<br>    <span class="hljs-function">const_pointer <span class="hljs-title">address</span> <span class="hljs-params">(const_reference value)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;value; &#125;<br><br>    <span class="hljs-comment">/* constructors and destructor</span><br><span class="hljs-comment">    * - nothing to do because the allocator has no state</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">MyAllocator</span>() <span class="hljs-keyword">throw</span>() &#123; &#125;<br>    <span class="hljs-built_in">MyAllocator</span>(<span class="hljs-type">const</span> MyAllocator&amp;) <span class="hljs-built_in">throw</span>() &#123; &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> U&gt;<br>        <span class="hljs-built_in">MyAllocator</span> (<span class="hljs-type">const</span> MyAllocator&lt;U&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; &#125;<br>    ~<span class="hljs-built_in">MyAllocator</span>() <span class="hljs-built_in">throw</span>() &#123; &#125;<br><br>    <span class="hljs-comment">// return maximum number of elements that can be allocated</span><br>    size_type <span class="hljs-built_in">max_size</span> () <span class="hljs-type">const</span> <span class="hljs-built_in">throw</span>() &#123;<br>        <span class="hljs-keyword">return</span> std::numeric_limits&lt;std::<span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">max</span>() / <span class="hljs-built_in">sizeof</span>(T);<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// return that all specializations of this allocator are interchangeable</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> MyAllocator&lt;T1&gt;&amp;,<br>                <span class="hljs-type">const</span> MyAllocator&lt;T2&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> MyAllocator&lt;T1&gt;&amp;,<br>                <span class="hljs-type">const</span> MyAllocator&lt;T2&gt;&amp;) <span class="hljs-built_in">throw</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br></code></pre></td></tr></table></figure><p>必须满足以上条件，该分配器才会自动工作。参考：</p><p><a href="http://www.josuttis.com/cppcode/myalloc.hpp.html">myalloc.hpp</a></p><h2 id="条款12：对STL容器线程安全性的期待现实一些"><a href="#条款12：对STL容器线程安全性的期待现实一些" class="headerlink" title="条款12：对STL容器线程安全性的期待现实一些"></a>条款12：对STL容器线程安全性的期待现实一些</h2><p>C++ 中的<strong>容器并不是多线程安全的</strong>，因为这会带来很大的开销。容器在多线程情况下能够实现的操作如下：</p><ul><li><strong>多个读取者是安全的</strong>。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器。</li><li>对<strong>不同容器的多个写入者是安全的</strong>。多线程可以同时写不同的容器。</li></ul><p>如果想要实现一个多线程安全的容器，要求如下：</p><ul><li>在每次调用容器的成员函数期间都要锁定该容器。</li><li>在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器。</li><li>在每个在容器上调用的算法执行期间锁定该容器。（这事实上没有意义，因为，正如条款32所解释的，算法没有办法识别出它们正在操作的容器。不过，我们将在这里检验这个选项，因为它的教育意义在于看看为什么即使是可能的它也不能工作。）</li></ul><p>这带来很大的线程锁（同步原语，如信号量机制）的资源开销。</p><p>在 Morden C++ 中，可以使用信号量保证多线程的同步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    mutex m;<br><br>    &#123;<br>        <span class="hljs-comment">// 使用互斥锁 必须手动  lock  unlock</span><br>        m.<span class="hljs-built_in">lock</span>();<br>        for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>        m.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    &#123;<br>        <span class="hljs-comment">// unique_lock 使用 RAII, 保证锁会 自动上锁 和 释放</span><br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;<br>        for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [] (<span class="hljs-type">int</span>&amp; a) &#123; cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Effective STL</tag>
      
      <tag>STL</tag>
      
      <tag>Containers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>llama2</title>
    <link href="/2024/03/14/llama2/"/>
    <url>/2024/03/14/llama2/</url>
    
    <content type="html"><![CDATA[<h1 id="LLaMa2"><a href="#LLaMa2" class="headerlink" title="LLaMa2"></a>LLaMa2</h1><h2 id="Transformer-Introduction"><a href="#Transformer-Introduction" class="headerlink" title="Transformer Introduction"></a>Transformer Introduction</h2><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>transformer 最主要的结构就是这张图：</p><p><img src="https://s2.loli.net/2024/03/13/WGRdjHr4MIOBKka.png" alt="Untitled.png"></p><p><img src="https://s2.loli.net/2024/03/13/KTXk7hmc9RPtYeA.png" alt="Untitled 1.png"></p><p>在纯 Encoder 或者纯 Decoder 的架构中，会变成只有左边的 transformer block 的结构，但是区别在于 Multi-Head Attention 是否存在 mask。Encoder-only 架构为了获取每一个 token 的完整上下文，因此没有对应的 mask；Decoder-only 架构为了让每一个 token 只能注意到它前面的 token，因此会存在一个从前往后的 mask，即生成的 $QK^T$ 矩阵（shape 为 $n_{tokens} \times n_{tokens}$）是一个下三角阵。</p><p><img src="https://s2.loli.net/2024/03/13/nXlmTSpWOjqhMaK.png" alt="llama2 的 QK^T 矩阵注意力输出，Decoder 架构，因此是一个下三角阵"></p><p>llama2 的 QK^T 矩阵注意力输出，Decoder 架构，因此是一个下三角阵</p><h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h3><p><a href="https://huggingface.co/blog/encoder-decoder">Transformer-based Encoder-Decoder Models</a></p><p>Transformer 是 Encoder-Decoder 结构的一种，这是为了解决在 NLP 中输入和输出长度不相同的问题，包括总结文本、生成新的文本。此前的 GRU 存在几个问题：1、Encoder 过长，会遗忘输入信息；2、Encoder 无法并行。（注意：Decoder 也无法并行，但是这是能够接受的，因为不知道输出的长度，因此只能每次输出一个 token）</p><p>为了一次 Encoder 推理捕获到全部的输入信息，transformer 将输入拼接起来，使用矩阵乘获取每个 token 之间的关系，然后通过 softmax 层变为系数矩阵，与输出的 V 矩阵相乘，得到了自注意力的输出。（为啥之前的 GRU 没有想到把所有的数据拼接，一次推理就能更新到最后的隐藏层的输出）</p><p>虽然预测推理时 Decoder 不能并行，但是训练时由于输出长度是已知的，所以使用了 Masked MHA 来进行并行化的训练。</p><p>输入和输出的 shape：$(N, \ N_{heads}, \ T, \ N_{embedding-size})$，$T$ 表示 time step，即输入 token 的数量；在 GPT 中，$T$ 随着输出不断变长。</p><p>注意：无论是 Encoder 还是 Decoder，它们输出的长度都是跟输入的长度是一样长的；在 Bert 中，输入是 masked sentence，输出是 reverse masked sentence，即对于被 mask 的单词的预测；在 GPT 中，它是一个生成任务，因此是通过不断地将输出拼接到输入中直到 token 为 EOS（End-Of-Sentence），由于输出和输入等长，因此输入是 $(BOS, x_1,x_2, \dots, x_{n-1})$，输出是 $(x_1,x_2,\cdots,x_n)$，最后一个 tensor 为当前输出的 token 的 embedding，通过 de-embedding 和 argmax 即可得到输出 token 的 id。</p><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><p>GPT 是 Decoder-only 的架构，用于生成式任务。如果我们没有任何的输入和 Prompt，那么第一个 token 为 BOS（Begin-Of-Sentence）。</p><p>在 PyTorch 中，由于支持变长输入，所以输入的生成应该是如下形式：</p><ol><li>BPE 序列化 Prompt 成 Embedding，与 Positional Encoding 相加，得到初始输入<ol><li>如果没有 prompt，使用 BOS</li></ol></li><li>每次输入得到相同长度的输出，取最后一个 step 的 tensor 为输出 token 的 embedding</li></ol><h2 id="Llama2-c"><a href="#Llama2-c" class="headerlink" title="Llama2.c"></a>Llama2.c</h2><h3 id="LLama2"><a href="#LLama2" class="headerlink" title="LLama2"></a>LLama2</h3><p><a href="https://github.com/facebookresearch/llama/blob/main/llama/model.py"></a></p><p><img src="https://s2.loli.net/2024/03/13/RHgxY4FyuzshkZj.png" alt="llama2 对于 prompt 的处理"></p><p>llama2 对于 prompt 的处理</p><p>llama2 保持 transformer 架构的基本模式，即通过堆叠 tranformer block 来使得模型变深；与 CV 模型不同的是，CV 模型由于卷积模块的增加，feature map 会缩小，通道数会增加，因此不同 size 和 channel 的 block 不相同；但是 transformer block 是完全相同的，同一个类型的 block 从头用到尾，这也是输入和输出 shape 相同的原因。</p><p><img src="https://s2.loli.net/2024/03/13/bPtGswMhyzO1Bca.png" alt="Untitled 4.png"></p><p>llama2 的 transformer block 如下：</p><!-- <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile&gt;&lt;diagram name=\&quot;Page-1\&quot; id=\&quot;IZTuIewHX-2reReE1Nqf\&quot;&gt;&lt;mxGraphModel dx=\&quot;1276\&quot; dy=\&quot;1163\&quot; grid=\&quot;0\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;0\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;850\&quot; pageHeight=\&quot;1100\&quot; background=\&quot;none\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;&lt;root&gt;&lt;mxCell id=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;22\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;2\&quot; target=\&quot;21\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;2\&quot; value=\&quot;Masked Multi-Head Attention\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-101\&quot; y=\&quot;297\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;14\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;5\&quot; target=\&quot;32\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;5\&quot; value=\&quot;RMSNorm\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-99\&quot; y=\&quot;440\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;12\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=0;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;6\&quot; target=\&quot;10\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;13\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;6\&quot; target=\&quot;8\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;89.00000000000011\&quot; y=\&quot;197\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;17\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;6\&quot; target=\&quot;26\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;-21\&quot; y=\&quot;90\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;6\&quot; value=\&quot;FFN\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-101\&quot; y=\&quot;109\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;8\&quot; value=\&quot;SwiGeLU\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;91\&quot; y=\&quot;129.5\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;10\&quot; value=\&quot;MatMul\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;91\&quot; y=\&quot;88.5\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;19\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;18\&quot; target=\&quot;5\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;35\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;18\&quot; target=\&quot;21\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;Array as=\&quot;points\&quot;&gt;&lt;mxPoint x=\&quot;-19\&quot; y=\&quot;507\&quot;/&gt;&lt;mxPoint x=\&quot;-122\&quot; y=\&quot;507\&quot;/&gt;&lt;mxPoint x=\&quot;-122\&quot; y=\&quot;256\&quot;/&gt;&lt;/Array&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;18\&quot; value=\&quot;X\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=#d79b00;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-47.5\&quot; y=\&quot;520\&quot; width=\&quot;57\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;25\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;20\&quot; target=\&quot;6\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;20\&quot; value=\&quot;RMSNorm\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-101\&quot; y=\&quot;173\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;24\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;21\&quot; target=\&quot;20\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;31\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;21\&quot; target=\&quot;26\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;Array as=\&quot;points\&quot;&gt;&lt;mxPoint x=\&quot;-21\&quot; y=\&quot;233\&quot;/&gt;&lt;mxPoint x=\&quot;-122\&quot; y=\&quot;233\&quot;/&gt;&lt;mxPoint x=\&quot;-122\&quot; y=\&quot;72\&quot;/&gt;&lt;/Array&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;21\&quot; value=\&quot;+\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-33.5\&quot; y=\&quot;243\&quot; width=\&quot;25\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;29\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;26\&quot; target=\&quot;30\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;-20.850753495127947\&quot; y=\&quot;22.790911721539715\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;26\&quot; value=\&quot;+\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-33.5\&quot; y=\&quot;60\&quot; width=\&quot;25\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;30\&quot; value=\&quot;Y\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=#d79b00;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-49.5\&quot; y=\&quot;-11\&quot; width=\&quot;57\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;33\&quot; style=\&quot;edgeStyle=none;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;endArrow=open;startSize=14;endSize=14;sourcePerimeterSpacing=8;targetPerimeterSpacing=8;\&quot; parent=\&quot;1\&quot; source=\&quot;32\&quot; target=\&quot;2\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;32\&quot; value=\&quot;Rotary Positional Encoding\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;-99\&quot; y=\&quot;368\&quot; width=\&quot;160\&quot; height=\&quot;41\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;/root&gt;&lt;/mxGraphModel&gt;&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script> --><p>由于 transformer 都是这种结构堆叠而成，因此许多推理框架都把结构硬编码放到代码中，包括下面的 LLama2.c。原始的 transformer 中间没有 Rotary Positional Encoding，这是 2021 年的 RoFormer 提出的，具体可参考 <strong><a href="https://kexue.fm/archives/8265">Transformer升级之路：2、博采众长的旋转式位置编码</a></strong> 。</p><h3 id="llama2-c"><a href="#llama2-c" class="headerlink" title="llama2.c"></a>llama2.c</h3><p><a href="https://github.com/karpathy/llama2.c">https://github.com/karpathy/llama2.c</a></p><p>llama2.c 根据上面的 llama2 的 transformer 的结构搭建了一个 transformer 的推理框架。主要介绍比较重要的几个模块。</p><p><strong>BPE Encoding</strong></p><p>部分分词法，能够得到英语中前后缀和词根，学习更多的数据。</p><p>算法如下：</p><ol><li>将句子拆分成字母，字母变为“子词”</li><li>合并其中两个相邻的子词成为一个新的子词，新子词的得分必须是最高的</li><li>不断迭代第二步，直到没有新的子词生成，即两个相邻子词生成的子词无法在词汇表中找到</li></ol><p><strong>Prompt</strong></p><p>prompt 可以理解为预先输入的一些单词，它们先走了一遍网络，初始化了权重，因此后面的输出才会根据 prompt 的提示输出。</p><p><strong>RMSNorm</strong></p><p>公式如下：</p><p>$$<br>X^\prime &#x3D; W \cdot \frac{X}{(\sum_{i&#x3D;1}^{n} X_i^2) &#x2F; n}<br>$$</p><p><strong>FFN</strong></p><p>公式如下：</p><p>$$<br>X^\prime &#x3D; W_2 \left ( (W_3 X) \cdot \text{SiLU} (W_1 X) \right )<br>$$</p><p>其中 $\text{SiLU}$ 函数如下：</p><p>$$<br>\text{SiLU}(x) &#x3D; x \cdot \sigma(x) &#x3D; \frac{x}{1 + \exp(-x)}<br>$$</p><p><strong>KV Cache</strong></p><p>由于 Decoder 每次推理生成一个 token，直到 token 为 EOS。每次推理得到的一个 token 会被视为新的输入再次执行推理，得到下一个 token。因此，之前生成的 Key 和 Value 矩阵可以保留下来，不需要再一次生成所有 token。</p><p>考虑到自注意力的公式为：</p><p>$$<br>\begin{align}<br>Q &amp;&#x3D; W_q X \<br>K &amp;&#x3D; W_k X \<br>V &amp;&#x3D; W_v X \<br>\text{Attn}(Q, K, V) &amp;&#x3D; Softmax \left ( \frac{QK^T}{\sqrt{n_{dim}}} \right )V<br>\end{align}<br>$$</p><p>假设有一行新的输入 $X_n$，经过投影后变为 $Q$ 的一行新的输入，经过自注意力后的输出与 $Q$ 的其它行无关，但是需要完整的 $K$ 和 $V$ 矩阵，因此我们需要 KV Cache。新的一行 KV Cache 就是新的输入 $X_n$ 经过投影之后的结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Transformer</tag>
      
      <tag>LLaMa2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用zerotier实现免费上网</title>
    <link href="/2024/03/14/zerotier-free-web/"/>
    <url>/2024/03/14/zerotier-free-web/</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>本文提到的操作需要使用一台机器进行中转，这个机器可以是服务器，也可以是自己工位上的 Windows 机器。同时，这个机器上还必须打开了 Clash、V2Ray、SSR 之类的代理，并拥有一个端口号。</p><p>基本原理：假设我们在宿舍有一台笔记本，称为 Alice，简称为 A；在工位上有一台电脑，称为 Bob，简称为 B。A 只能访问校园网的网站，例如 csu.edu.cn；B 能够访问互联网，例如 baidu.com。那么，如果我们能够实现 A 的 https 请求通过 B 进行转发，然后再由 B 转发回 A，也就实现了让 A 上网。如图，</p><p><img src="https://s2.loli.net/2024/03/14/ykRW5ulcz8vHJQV.png" alt="image0.png"></p><p>从密码学角度来想，Bob 就是 Alice 和 Internet 的中间人，它可以获取二者通信的所有内容，所以我们要保证 Bob 一定是可信的。如果 Bob 不可信，我们还可以通过 https 进行通信，https 的所有信息都是被加密过的，如果 Bob 没有解密私钥，他就无法窃取机密信息。如何进行私钥分发，保证私钥的隐私性和不篡改性？一般是通过第三方的公证机构，所以 https 的认证证书是收费的。</p><p>要实现以上的连接，我们需要两个工具：</p><ul><li>实现 A 和 B 之间通信的工具，zerotier，这个是为了获取 IP。</li><li>B 为 A 做代理的软件，一般的代理软件都可以，例如 Clash、V2Ray、SSR，这个是为了获取代理端口。</li></ul><p>实际上，还是绕回了上一文中的，代理的两个关键变量：IP 和端口。</p><h2 id="Zerotier"><a href="#Zerotier" class="headerlink" title="Zerotier"></a>Zerotier</h2><h3 id="Zerotier-原理"><a href="#Zerotier-原理" class="headerlink" title="Zerotier 原理"></a>Zerotier 原理</h3><p>为什么我们需要 zerotier？我们可以简单地把 zerotier 理解为打洞软件。因为 IPv4 的 IP 池不够用，所以产生了 NAT 技术，这样可以让一个 IP 被很多人一起使用，从而保证了基于 IPv4 的互联网的可用性。但是，这也有缺点，很多人都使用同一个 IP，那么 P2P 通信很难实现，并且也很难追踪数据的来源（所以知乎显示的 IP 都是省级的）。</p><p>在 NAT 环境下，为了实现 P2P 通信，可以使用的一个技术叫做打洞。具体实现原理我不是非常清楚，但是可以简要地说明一下。假设 A（192.168.1.*） 和 B（172.16.6.*） 之间有一个路由器 C，但是路由器两边的 IP 不同。B 可以向 A 发送数据包，但是 A 不能向 B 发送数据包，存在一个通信的 gap。NAT 技术的原理是二者进行通信的时候，对于公用的 IP，路由器会记录源IP、源端口、目标 IP、目标端口，本来 NAT 是一个 IP 层的技术，但是为了解决通信的问题，它使用了 TCP 层的技术。如果我们能够确保 C 上的一个端口永远是被 B 所占用的，那么 A 可以向 C 的这个端口发送数据包，这个数据包就可以保证被 B 所接收，这样就实现了二者的 P2P 通信。<br>在校园网环境下，实际的路由情况比较复杂，我的测试结果是从宿舍到实验室，中间应该经过了 5 层路由。</p><h3 id="Tracert-测试"><a href="#Tracert-测试" class="headerlink" title="Tracert 测试"></a>Tracert 测试</h3><p>为了保证宿舍和实验室之间是存在路由关系，并且保证是在学校内网中的。我们需要先测试一下，使用的工具是 Windows 自带的 tracert 工具，在 Linux 上是 traceroute。</p><p>首先，在宿舍，连接 CSU-Student，一定要使用 WiFi 连接，因为我发现 WiFi 连接之后，打洞的延迟很低，在 4~10ms 左右波动，而网线连接的延迟很高，基本在 300ms 以上。</p><p><img src="https://s2.loli.net/2024/03/14/sp7N1ubTx2QF4D9.png" alt="image1.png"></p><p>连接 WiFi 之后，打开浏览器进行认证，随便访问一个网站就会自动跳转到认证网页了。注意：此时浏览器代理或者全局代理软件都不能打开，否则流量会被劫持，从而被转发到代理网站上，而代理网站不能连接，也就既不能认证又不能上网。认证网页，记得选择校园网，校园网可以免费登录：</p><p><img src="https://s2.loli.net/2024/03/14/YDt1TSR73JHeNj9.png" alt="image2.png"></p><p>认证成功：</p><p><img src="https://s2.loli.net/2024/03/14/psIiybme18SOGX7.png" alt="image3.png"></p><p>认证成功之后，可以访问各种学校网站，例如官网 csu.edu.cn、计算机学院官网 cse.csu.edu.cn。所以，我们要使用 tracert 测试宿舍机器到 csu.edu.cn 的连通性。如图，</p><p><img src="https://s2.loli.net/2024/03/14/OuEfmLRhUSBlnbg.png" alt="image4.png"></p><p><img src="https://s2.loli.net/2024/03/14/AZ4SxMUGONXkVhe.png" alt="image5.png"></p><p>第一张图是在宿舍环境下的 tracert 测试，第二张图是在实验室环境下的 tracert 测试。可以发现，两台机器都访问了同一个 IP，172.30.200.2，说明这两台机器之间是存在路由连接的，因此我们通过打洞实现二者之间的 P2P 通信是可行的。</p><h3 id="Zerotier-安装"><a href="#Zerotier-安装" class="headerlink" title="Zerotier 安装"></a>Zerotier 安装</h3><p>到 zerotier 官网下载，直接安装即可。安装之后的界面：</p><p><img src="https://s2.loli.net/2024/03/14/MpX6iQAekT9CF4g.png" alt="image6.png"></p><p>可以看到，右下角多了一个正在运行的软件。a84ac5c10a851cf8 是我自己创建的虚拟局域网。如果需要加入一个虚拟局域网，我们首先需要自己创建一个 zerotier 账号，并且创建一个虚拟局域网。当创建好虚拟局域网之后，在每台设备上加入组建的虚拟局域网。两台机器都加入之后，还需要到 zerotier 控制台中进行额外的配置。如图所示，</p><p><img src="https://s2.loli.net/2024/03/14/LChtn1Ra8KqJ5BH.png" alt="image7.png"></p><p>因为默认创建的虚拟局域网是私有的，所以必须点上 Auth 的按钮。同时，还可以给它分配一个 IP 和名称。做好以上步骤之后，就可以 zerotier 帮我们实现自动打洞了。</p><p>注意，Windows 会默认打开防火墙，所以 ping 是会失败的。最简单的是在被连接的电脑 B 上关闭防火墙，虽然比较危险，但是在实验室内也只发现了一次挖矿病毒，所以不需要特别在意。如果担心防火墙打开的风险，也可以在测试完之后关闭。</p><h3 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h3><p>由于 Windows 关闭了 ICMP 端口的连接，所以是无法直接 ping 通的。最简单的方法是关闭防火墙，也可以通过 控制面板 -&gt; 系统和安全 -&gt; Windows Defender 防火墙 -&gt; 高级设置 -&gt; 入站规则 进行配置入站规则，将四个核心网络诊断 - ICMP回显请求打开（右键，启用规则）。如图，</p><p><img src="https://s2.loli.net/2024/03/14/2ZSblMydnKuXQeG.png" alt="image8.png"></p><p>本来是不可以 ping 通的，但是在打开之后，就可以 ping 通了。</p><p><img src="https://s2.loli.net/2024/03/14/v78HdnlK3t6ZEwA.png" alt="image9.png"></p><p>测试的方式：打开控制台，输入 ping ${IP_of_A} ，如上图所示。如果在已经打开了 ICMP 的情况下，并且延迟正常显示，那么就说明两台机器之间可以正常通信了。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理就比较简单了，只需要提供一个端口即可。我使用的是 Clash，像上文提到的那样，找到 Clash 的代理端口，那么这个就是我们需要连接的代理端口了。</p><p>[图片]</p><p>如果是 V2ray 和 SSR，在设置里面也有。</p><p>在拥有了 IP 和端口号之后，我们就可以把 B 视为我们的代理服务器，让 B 代替我们进行互联网访问，并且，由于这个端口号上监听的程序本来就是一个代理软件，我们的流量就可以自动地走代理程序，可以直接访问谷歌。<br>注意：代理的端口号也是被 Windows 防火墙关闭了的，所以，必须在入站规则中打开对应的代理端口，否则也是无法连接的。</p><h3 id="Clash-配置"><a href="#Clash-配置" class="headerlink" title="Clash 配置"></a>Clash 配置</h3><p>下载我的 clash 配置文件，并手动修改对应的 IP 和端口号。修改完成之后，在 profiles 界面导入配置文件。并且，点击右图中的测速按钮，可以得到延迟的大小。如果这个延迟是绿色的，那么就说明网络连接成功，可以使用。打开 General 界面的 System Proxy 按钮，这时整个系统的代理都会被 Clash 劫持。打开浏览器，就可以正常上网了。</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">proxies:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">10.147</span><span class="hljs-number">.20</span><span class="hljs-number">.2</span>  <span class="hljs-comment"># set your virtual remote IP provided by zerotier</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">7890</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">backup</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">10.147</span><span class="hljs-number">.20</span><span class="hljs-number">.3</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">7890</span><br><br><span class="hljs-attr">proxy-groups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Proxy</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">select</span><br>    <span class="hljs-attr">proxies:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backup</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Game</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">select</span><br>    <span class="hljs-attr">proxies:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backup</span><br>      <br><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">DOMAIN-SUFFIX,steampowered,Game</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">MATCH,</span> <span class="hljs-string">Proxy</span>  <span class="hljs-comment"># all connections fallback to remote</span><br></code></pre></td></tr></table></figure><h3 id="System-Proxy-配置"><a href="#System-Proxy-配置" class="headerlink" title="System Proxy 配置"></a>System Proxy 配置</h3><p>如果不想使用 Clash 做代理软件，也可以直接用 Windows 自带的代理设置，实际上，各种代理软件都是修改这个设置来劫持系统流量的。在 设置 -&gt; 网络和Internet -&gt; 代理 中，选择 手动设置代理 ，并填入对应的 B 机器的虚拟局域网的 IP 和端口，就可以正常代理，并上网了。</p><h3 id="测速"><a href="#测速" class="headerlink" title="测速"></a>测速</h3><p><img src="https://s2.loli.net/2024/03/14/B6g8pur2zlCaoDO.png" alt="image12.png"></p><p>基本上可以跑满实验室的带宽。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>只有 PC 可用，而且只能用在 WiFi 上</li><li>Zerotier 打洞不稳定，截至 2022.09.29，我用了十几天，有一天存在断流，网速只有 20Mbps</li></ol><p>参考<br><a href="https://kenvix.com/post/use-school-network-without-paying-guide/">https://kenvix.com/post/use-school-network-without-paying-guide/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Caffe2 中 float32 与 float16 的转换</title>
    <link href="/2024/03/12/float32-to-float16-caffe/"/>
    <url>/2024/03/12/float32-to-float16-caffe/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">generated by Copilot and translated by DeepL</p><p>这段 C++ 代码是一个名为 <code>cpu_float2half_rn</code> 的函数，用于将单精度浮点数（32 位）转换为半精度浮点数（16 位）。该函数将浮点数作为参数，并返回一个 float16 对象。转换过程涉及多个步骤，包括处理 NaN 和无穷大等特殊情况，从输入中提取符号、指数和尾数，以及四舍五入到最接近的偶数。</p><ol><li>函数首先声明了一个 float16 对象 ret，用于保存转换结果。然后使用 <code>static_assert</code> 来确保无符号 int 和 float 的大小相同。这一点很重要，因为函数使用位操作来处理 float 的二进制表示，这需要将 float 解释为无符号整数。</li><li>函数使用 <code>reinterpret_cast</code> 获得指向 float 二进制表示形式的指针。然后创建该二进制表示的副本，屏蔽符号位，得到浮点数 u 的绝对值。</li><li>函数会处理特殊情况。如果 u 大于 0x7f800000，输入值为 NaN，函数会将结果设置为特殊的 NaN 值并返回。如果 u 大于 0x477fefff 或小于 0x33000001，则输入值为无穷大或零，函数会将结果设置为适当的值并返回。</li><li>函数从浮点数的二进制表示中提取符号、指数和尾数。符号是最高位，指数是接下来的 8 位，尾数是剩余的 23 位。</li><li>函数会调整指数和尾数，以适应较小的半精度格式。如果指数大于 0x70，则从指数中减去 0x70，并将尾数右移 13 位。否则，它会将指数设为 0，设置尾数的最高位，并计算尾数右移的位数。</li><li>函数将尾数四舍五入为最接近的偶数。计算移位后的最小有效位及其以下的位数。如果最小有效位以下的位数大于一半或正好是一半，且最小有效位为 1，则尾数递增。如果尾数溢出，则递增指数并重置尾数。</li><li>函数将符号、指数和尾数合并为半精度格式，并将结果存储在 ret 中。然后返回 ret。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> float16 <span class="hljs-title">cpu_float2half_rn</span><span class="hljs-params">(<span class="hljs-type">float</span> f)</span> </span>&#123;<br>  float16 ret;<br><br>  <span class="hljs-built_in">static_assert</span>(<br>      <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>),<br>      <span class="hljs-string">&quot;Programming error sizeof(unsigned int) != sizeof(float)&quot;</span>);<br><br>  <span class="hljs-type">unsigned</span>* xp = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*&gt;(&amp;f);<br>  <span class="hljs-type">unsigned</span> x = *xp;<br>  <span class="hljs-type">unsigned</span> u = (x &amp; <span class="hljs-number">0x7fffffff</span>), remainder, shift, lsb, lsb_s1, lsb_m1;<br>  <span class="hljs-type">unsigned</span> sign, exponent, mantissa;<br><br>  <span class="hljs-comment">// Get rid of +NaN/-NaN case first.</span><br>  <span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">0x7f800000</span>) &#123;<br>    ret.x = <span class="hljs-number">0x7fff</span>U;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  sign = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0x8000</span>);<br><br>  <span class="hljs-comment">// Get rid of +Inf/-Inf, +0/-0.</span><br>  <span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">0x477fefff</span>) &#123;<br>    ret.x = sign | <span class="hljs-number">0x7c00</span>U;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0x33000001</span>) &#123;<br>    ret.x = (sign | <span class="hljs-number">0x0000</span>);<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  exponent = ((u &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>);<br>  mantissa = (u &amp; <span class="hljs-number">0x7fffff</span>);<br><br>  <span class="hljs-keyword">if</span> (exponent &gt; <span class="hljs-number">0x70</span>) &#123;<br>    shift = <span class="hljs-number">13</span>;<br>    exponent -= <span class="hljs-number">0x70</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    shift = <span class="hljs-number">0x7e</span> - exponent;<br>    exponent = <span class="hljs-number">0</span>;<br>    mantissa |= <span class="hljs-number">0x800000</span>;<br>  &#125;<br>  lsb = (<span class="hljs-number">1</span> &lt;&lt; shift);<br>  lsb_s1 = (lsb &gt;&gt; <span class="hljs-number">1</span>);<br>  lsb_m1 = (lsb - <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// Round to nearest even.</span><br>  remainder = (mantissa &amp; lsb_m1);<br>  mantissa &gt;&gt;= shift;<br>  <span class="hljs-keyword">if</span> (remainder &gt; lsb_s1 || (remainder == lsb_s1 &amp;&amp; (mantissa &amp; <span class="hljs-number">0x1</span>))) &#123;<br>    ++mantissa;<br>    <span class="hljs-keyword">if</span> (!(mantissa &amp; <span class="hljs-number">0x3ff</span>)) &#123;<br>      ++exponent;<br>      mantissa = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  ret.x = (sign | (exponent &lt;&lt; <span class="hljs-number">10</span>) | mantissa);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ORT 模型部署</title>
    <link href="/2024/03/12/Deploy-ORT-model/"/>
    <url>/2024/03/12/Deploy-ORT-model/</url>
    
    <content type="html"><![CDATA[<h1 id="Deploy-ORT-model"><a href="#Deploy-ORT-model" class="headerlink" title="Deploy ORT model"></a>Deploy ORT model</h1><p><a href="https://github.com/microsoft/onnxruntime-inference-examples/blob/main/quantization/notebooks/imagenet_v2/mobilenet.ipynb">onnxruntime-inference-examples&#x2F;mobilenet.ipynb at main · microsoft&#x2F;onnxruntime-inference-examples</a></p><p><a href="https://zhuanlan.zhihu.com/p/128974102">详细记录YOLACT实例分割ncnn实现</a></p><p>真正部署模型，不应该把后处理包括在模型推理中，这会影响模型在GPU上的部署，性能也不一定会好。这里的后处理，不仅仅是<code>model(input)</code> 之后的，也可以是作者放在模型推理过程中，但是实际上可以归为后处理的部分。</p><p>判断函数是否在ONNX trace的过程中：<code>torch.onnx.is_in_onnx_export()</code> 。</p><p><a href="https://www.notion.so/ONNX-to-TF-6049662a9e71472aaff545676a19050c">ONNX to TF</a></p><h2 id="Torch-to-ONNX"><a href="#Torch-to-ONNX" class="headerlink" title="Torch to ONNX"></a>Torch to ONNX</h2><ol><li>torch不支持<code>F.grid_sample</code> 算子。从<a href="https://github.com/onnx/onnx/blob/main/docs/Operators.md">ONNX支持的算子列表</a>来看，<code>opset=16</code> 时，可以直接使用<code>grid_sampler</code> 而不需要手动设置符号函数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># https://github.com/pytorch/pytorch/issues/27212#issuecomment-1059773074</span><br><span class="hljs-comment"># https://gist.github.com/daigo0927/8c8b3005cffb61983e80ceab6c1f2274</span><br><span class="hljs-comment"># https://github.com/onnx/onnx/pull/3557</span><br><br><span class="hljs-keyword">from</span> torch.onnx <span class="hljs-keyword">import</span> register_custom_op_symbolic<br><span class="hljs-keyword">import</span> torch.onnx.symbolic_helper <span class="hljs-keyword">as</span> sym_help<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grid_sampler</span>(<span class="hljs-params">g, <span class="hljs-built_in">input</span>, grid, mode, padding_mode, align_corners</span>):<br>    <span class="hljs-comment"># mode</span><br>    <span class="hljs-comment">#   &#x27;bilinear&#x27;      : onnx::Constant[value=&#123;0&#125;]</span><br>    <span class="hljs-comment">#   &#x27;nearest&#x27;       : onnx::Constant[value=&#123;1&#125;]</span><br>    <span class="hljs-comment">#   &#x27;bicubic&#x27;       : onnx::Constant[value=&#123;2&#125;]</span><br>    <span class="hljs-comment"># padding_mode</span><br>    <span class="hljs-comment">#   &#x27;zeros&#x27;         : onnx::Constant[value=&#123;0&#125;]</span><br>    <span class="hljs-comment">#   &#x27;border&#x27;        : onnx::Constant[value=&#123;1&#125;]</span><br>    <span class="hljs-comment">#   &#x27;reflection&#x27;    : onnx::Constant[value=&#123;2&#125;]</span><br>    mode = sym_help._maybe_get_const(mode, <span class="hljs-string">&quot;i&quot;</span>)<br>    padding_mode = sym_help._maybe_get_const(padding_mode, <span class="hljs-string">&quot;i&quot;</span>)<br>    mode_str = [<span class="hljs-string">&#x27;bilinear&#x27;</span>, <span class="hljs-string">&#x27;nearest&#x27;</span>, <span class="hljs-string">&#x27;bicubic&#x27;</span>][mode]<br>    padding_mode_str = [<span class="hljs-string">&#x27;zeros&#x27;</span>, <span class="hljs-string">&#x27;border&#x27;</span>, <span class="hljs-string">&#x27;reflection&#x27;</span>][padding_mode]<br>    align_corners = <span class="hljs-built_in">int</span>(sym_help._maybe_get_const(align_corners, <span class="hljs-string">&quot;b&quot;</span>))<br><br>    <span class="hljs-keyword">return</span> g.op(<span class="hljs-string">&quot;com.microsoft::GridSample&quot;</span>, <span class="hljs-built_in">input</span>, grid,<br>                mode_s=mode_str,<br>                padding_mode_s=padding_mode_str,<br>                align_corners_i=align_corners)<br>    <br>register_custom_op_symbolic(<span class="hljs-string">&#x27;::grid_sampler&#x27;</span>, grid_sampler, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li><code>_DCNv2</code> 完全不受支持。它是用CUDA编译的，无论是自带的DCNv2还是mmcv的DCNv2。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">symbolic</span>(<span class="hljs-params"></span><br><span class="hljs-params">    g, <span class="hljs-built_in">input</span>, offset, mask, weight, bias, stride, padding, dilation, deformable_groups</span><br><span class="hljs-params"></span>):<br>    <span class="hljs-keyword">from</span> torch.nn.modules.utils <span class="hljs-keyword">import</span> _pair<br><br>    stride = _pair(stride)<br>    padding = _pair(padding)<br>    dilation = _pair(dilation)<br>    <span class="hljs-comment"># as of trt 7, the dcn operation will be translated again by modifying the onnx file</span><br>    <span class="hljs-comment"># so the exporting code is kept to resemble the forward()</span><br>    <span class="hljs-keyword">return</span> g.op(<br>        <span class="hljs-string">&quot;custom_domain::_DCNv2&quot;</span>,<br>        <span class="hljs-built_in">input</span>,<br>        offset,<br>        mask,<br>        weight,<br>        bias,<br>        stride_i=stride,<br>        padding_i=padding,<br>        dilation_i=dilation,<br>        deformable_groups_i=deformable_groups,<br>    )<br></code></pre></td></tr></table></figure><p>在这里可以注册一个符号函数(<code>symbolic_function</code>)来自己手动通过cpp实现DCNv2，但是我其实并不确定它能不能运行到mobile端。最上面导出NCNN的方法其实说过，可以跳过它，就是不用它，换到一个Conv层就行。在实现层面上，参考下面的模型变量key：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span>:<span class="hljs-string">&#x27;dla.ida_up.proj_1.conv.weight&#x27;</span><br><span class="hljs-number">6</span>:<span class="hljs-string">&#x27;dla.ida_up.proj_1.conv.bias&#x27;</span><br><span class="hljs-number">7</span>:<span class="hljs-string">&#x27;dla.ida_up.proj_1.conv.conv_offset_mask.weight&#x27;</span><br><span class="hljs-number">8</span>:<span class="hljs-string">&#x27;dla.ida_up.proj_1.conv.conv_offset_mask.bias&#x27;</span><br></code></pre></td></tr></table></figure><p>它自带了一个conv，同时还有一个conv_offset_mask来学习stride的微小偏移量，这使得我们可以不使用后面的conv_offset_mask，只使用conv本身的权重来推理。不过这样会丢掉一些性能。下面这个用的是TensorRT推理，所以可以支持CUDA。DCNv2的实现中，其中一个就是参考了这个repo的。它这里面实现了自定义的算子，并且用符号函数把算子和onnx计算图联系到了一起。</p><p><a href="https://github.com/CaoWGG/TensorRT-CenterNet/blob/master/readme/ctdet2onnx.md">TensorRT-CenterNet&#x2F;ctdet2onnx.md at master · CaoWGG&#x2F;TensorRT-CenterNet</a></p><ol start="3"><li><code>Floating point exception (core dumped)</code> 。这个报错出现地非常地无厘头，因为它没有任何报错栈，只是单纯地显示它出错了。如果用torch1.9，会有更多的报错信息，虽然基本上也看不了。截图如下：</li></ol><p><img src="https://s2.loli.net/2024/03/12/tpTenzEYO7GFwB6.png" alt="raw_error.png"></p><p><a href="https://discuss.pytorch.org/t/dealing-with-floating-point-exceptions/51882/3">Dealing with floating point exceptions</a></p><p>通过<code>gdb --args python [finetune.py](http://finetune.py) $&#123;params&#125;</code> ，可以查看到更多的报错信息，截图如下：</p><p><img src="https://s2.loli.net/2024/03/12/oIicYZWQ9tR1Av7.png" alt="gdb_callstack.png"></p><h2 id="ONNX-to-ORT"><a href="#ONNX-to-ORT" class="headerlink" title="ONNX to ORT"></a>ONNX to ORT</h2><ol><li>除法算子导致张量除法的datatype不对应。<code>onnxruntime.capi.onnxruntime_pybind11_state.Fail: [ONNXRuntimeError] : 1 : FAIL : Load model from /media/tclab/980Pro/users/bangwhe/e2ec/gcn.onnx failed:Type Error: Type parameter (T) of Optype (Div) bound to different types (tensor(double) and tensor(float) in node (Div_337).</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原代码</span><br>img_poly[..., <span class="hljs-number">0</span>] = img_poly[..., <span class="hljs-number">0</span>] / (w / <span class="hljs-number">2.</span>) - <span class="hljs-number">1</span><br>img_poly[..., <span class="hljs-number">1</span>] = img_poly[..., <span class="hljs-number">1</span>] / (h / <span class="hljs-number">2.</span>) - <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修改后的代码，w先做除法</span><br>img_poly[..., <span class="hljs-number">0</span>] = img_poly[..., <span class="hljs-number">0</span>] / w * <span class="hljs-number">2.</span> - <span class="hljs-number">1</span><br>img_poly[..., <span class="hljs-number">1</span>] = img_poly[..., <span class="hljs-number">1</span>] / h * <span class="hljs-number">2.</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ol start="2"><li>循环中的<code>==</code> 生成了bool，可能不受支持。<code>onnxruntime.capi.onnxruntime_pybind11_state.InvalidGraph: [ONNXRuntimeError] : 10 : INVALID_GRAPH : Load model from /media/tclab/980Pro/users/bangwhe/e2ec/gcn.onnx failed:This is an invalid model. Type Error: Type &#39;tensor(bool)&#39; of input parameter (763) of operator (ScatterND) in node (ScatterND_543) is invalid.</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原代码</span><br>batch_size = cnn_feature.size(<span class="hljs-number">0</span>)<br>gcn_feature = torch.zeros([img_poly.size(<span class="hljs-number">0</span>), cnn_feature.size(<span class="hljs-number">1</span>), img_poly.size(<span class="hljs-number">1</span>)]).to(img_poly.device)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_size):<br>    poly = img_poly[ind == i].unsqueeze(<span class="hljs-number">0</span>)<br>    feature = torch.nn.functional.grid_sample(cnn_feature[i:i+<span class="hljs-number">1</span>], poly)[<span class="hljs-number">0</span>].permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    gcn_feature[ind == i] = feature<br><br><span class="hljs-comment"># 修改后的代码</span><br>gcn_feature[<span class="hljs-number">0</span>] = torch.nn.functional.grid_sample(cnn_feature[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], img_poly[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>].unsqueeze(<span class="hljs-number">0</span>))[<span class="hljs-number">0</span>].permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="ORT-NNAPI"><a href="#ORT-NNAPI" class="headerlink" title="ORT NNAPI"></a>ORT NNAPI</h2><p><a href="https://github.com/BangwenHe/ORTSegDemo">https://github.com/BangwenHe/ORTSegDemo</a></p><p><a href="https://github.com/microsoft/onnxruntime/blob/master/java/src/test/java/sample/ScoreMNIST.java">onnxruntime&#x2F;ScoreMNIST.java at master · microsoft&#x2F;onnxruntime</a></p><p><a href="https://github.com/microsoft/onnxruntime-inference-examples/blob/main/mobile/examples/image_classification/android/app/src/main/java/ai/onnxruntime/example/imageclassifier/ImageUtil.kt">onnxruntime-inference-examples&#x2F;ImageUtil.kt at main · microsoft&#x2F;onnxruntime-inference-examples</a></p><p>导出成onnx或者ort模型后，部署到手机上肯定是会支持CPU的，但是是否支持GPU还需要看模型的支持或者NNAPI的支持。增加CPU的线程数可以直接使用<code>mSessionOptions.setIntraOpNumThreads(4);</code> ，肯定是支持的。</p><ol><li>shape错误，应该是slice（切片）算子不受到NNAPI的支持。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">W/System.err: ai.onnxruntime.OrtException: Error code - ORT_FAIL - <br>message: model_builder.cc:<span class="hljs-number">374</span> RegisterModelOutputs shape_proto cannot be null <span class="hljs-keyword">for</span> output: <span class="hljs-number">217</span><br></code></pre></td></tr></table></figure><ol start="2"><li>我认为我导出的这个e2ec或者是snake不能运行到mobile端的GPU上应该是因为添加了太多的逻辑运算，而不仅仅是Conv、BN、ReLU这些算子，例如NonZero，还有一些多维取值算子，例如ScatterND、Gather等。这些逻辑算子和取值算子对于逻辑运算单元少的GPU来说，并行起来是非常困难的。所以优化的角度应该是把类似后处理的逻辑运算给提取出来，只保留大部分的backbone，手动从heatmap中提取关键点的位置信息，<a href="https://storage.googleapis.com/download.tensorflow.org/models/tflite/posenet_mobilenet_v1_100_257x257_multi_kpt_stripped.tflite">posenet</a>输出的就是heatmap，需要手动做提取。</li></ol><h2 id="Build-ONNXRuntime-From-Source"><a href="#Build-ONNXRuntime-From-Source" class="headerlink" title="Build ONNXRuntime From Source"></a>Build ONNXRuntime From Source</h2><p><a href="https://onnxruntime.ai/docs/build/android.html">Build for Android</a></p><p>要求cmake 3.18+，android SDK需要手动通过sdkmanager下载。加上<code>--build_java</code> 会很慢，所以先删掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/mnt/tbdisk/bangwhe/experiments/cmake-3.20.6-linux-x86_64/bin/:<span class="hljs-variable">$PATH</span><br><br>./build.sh --android --build_nnapi\<br>--android_sdk_path /mnt/tbdisk/bangwhe/env/Android/platforms/android-29/ \<br>--android_ndk_path /mnt/tbdisk/bangwhe/env/android-ndk-r20b/<br></code></pre></td></tr></table></figure><p>编译得到的so库都保存在build文件夹中，下面有子文件夹，分别保存安卓端和Linux桌面端。</p><h2 id="OnnxRuntime-C-Impl"><a href="#OnnxRuntime-C-Impl" class="headerlink" title="OnnxRuntime C++ Impl"></a>OnnxRuntime C++ Impl</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a href="https://github.com/microsoft/onnxruntime-inference-examples/blob/main/c_cxx/model-explorer/model-explorer.cpp">onnxruntime-inference-examples&#x2F;model-explorer.cpp at main · microsoft&#x2F;onnxruntime-inference-examples</a></p><p><code>error: use of deleted function ‘Ort::Experimental::Session::Session(const Ort::Experimental::Session&amp;)</code> ：函数被删除了，后面有debug信息。这个session不能通过函数传到其它的函数里，从而被调用。<code>Ort::Value</code> 也是一样的，但是通过<code>std::move</code> 将其变成右值，就可以传到<code>vector</code> 中。（Why？）</p><p>vscode添加索引路径：command palette → C&#x2F;C++: Edit Configurations (JSON)</p><p><code>2022-08-15 10:50:20.544504982 [W:onnxruntime:, graph.cc:1220 Graph] Initializer 1894 appears in graph inputs and will not be treated as constant value/weight. This may prevent some of the graph optimizations, like const folding. Move it out of graph inputs if there is no need to override it, by either re-generating the model with latest exporter/converter or with the tool onnxruntime/tools/python/remove_initializer_from_input.py.</code> initializer 1894 出现在图形输入中，不会被视为常量值&#x2F;权重，可能会阻止一些类似常量折叠的优化，可以使用<code>onnxruntime/tools/python/remove_initializer_from_input.py</code> 来进行移除操作。移除前的推理时间是45ms，移除后是19ms，提升还是比较大的。</p><p><code>cv:dnn:blobFromImage</code> 不太好用，经常把320x320的Mat变成3x1的Mat。（Why？）</p><p>OpenCV的<code>Mat</code> 类和ORT的<code>Ort::Value</code> 类都可以得到它们的数据指针，方法分别是：</p><ul><li><code>[Mat.data](http://Mat.data)</code> 可以直接得到数据的指针，但是更常用的是<code>Mat.at&lt;DataType&gt;()</code></li><li><code>Ort::Value::GetTensorMutableData&lt;DataType&gt;()</code> ，得到<code>Ort::Value</code> 保存的张量的数据指针</li><li>通过这两个指针，我们可以得到预处理得到的结果和输入网络前的张量的大小。如果需要对比预处理是否相同，可以自己读指针，然后打印数据出来跟python版的数据做对比。</li></ul><p><code>terminate called after throwing an instance of &#39;Ort::Exception&#39; what():  not enough space: expected 1228800, got 409600</code> ：明显的报错，空间不够。这是因为传入的<code>p_data_element_count</code> 和<code>*shape</code> 的乘积大小不相同，所以导致了报错，传入的参数为<code>102400</code> 和<code>307200</code> ，再乘上float类型占用的4byte，有<code>409600</code> 和<code>1228800</code> ，所以商（3）代表少了三个通道，给<code>p_data_element_count</code> 乘上3即可。</p><p><code>incomplete type is not allowed</code> ：需要先定义一个type，才能在后续使用这个标识符的时候知道它是啥。这里报错是因为OrtSession这个类（标识符）不存在，需要变成指针类型才可以，即OrtSession*类型。</p><p><a href="https://www.notion.so/02-32a4f1797c1b46758f2a01ed714970bf">02</a></p><p><code>error: use of deleted function ‘Ort::Session::Session(const Ort::Session&amp;)’</code> ：使用了被删除的拷贝构造函数，所以不能把它当作变量传到某一个函数中，编译器就会报错（为什么会删除呢？参考我的02）。那我们总不可能不用函数吧？在<a href="https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/onnxruntime_c_api.h#L3500">3501</a>行，注释中说：</p><blockquote><p>Prevent users from accidentally copying the API structure, it should always be passed as a pointer.</p></blockquote><p>所以我们应该传入一个指针。从类名往上溯源，发现一个<code>Base</code> 类，它有一个函数：<code>operator T*() &#123; return p_; &#125;</code> ，这个是类型转换的函数，所以我们只需要把Session转换成它的包装类即可，即</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">getOutputInfo((<span class="hljs-name">OrtSession*</span>) session)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>a nonstatic member reference must be relative to a specific object</code> ：函数不是静态函数，所以必须通过方法访问。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>安卓平台和Linux平台的实现基本上都是一样的，参考我的两个demo：<a href="https://github.com/BangwenHe/ORTSegDemo%E5%92%8Chttps://github.com/BangwenHe/ort-snake-cpp%E3%80%82%E4%B8%BB%E8%A6%81%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%B0%B1%E6%98%AF%E7%BC%96%E5%86%99cmake%EF%BC%8C%E9%80%9A%E8%BF%87cmake%E6%8A%8A%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84so%E5%BA%93%E9%93%BE%E6%8E%A5%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E3%80%82%E5%AE%89%E5%8D%93%E4%B8%8A%E6%9B%B4%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86JNI%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82">https://github.com/BangwenHe/ORTSegDemo和https://github.com/BangwenHe/ort-snake-cpp。主要的步骤就是编写cmake，通过cmake把预编译的so库链接到项目中。安卓上更需要考虑怎么处理JNI，以及编译的问题。</a></p><p>JNI的影响是jstring到string，long到jlong。</p><p>编译：由于java版本和c++版本都有<code>libonnxruntime.so</code> 这个文件，所以如果打包到一起，会导致文件重复而报错。</p><p>我写了一个 OnnxRuntime 手机端推理的 Demo，OrtSegDemo。只要能够导出 ONNX 文件，就可以用它在 CPU 上实现推理，GPU 不一定能够成功。下面是用法：</p><p><img src="https://s2.loli.net/2024/03/12/bAGS7psJmnuhz2x.png" alt="1280X1280.PNG"></p><p>需要修改的地方就是上面三个箭头指向的地方：</p><ol><li>把导出的 ONNX 模型放到 raw 文件夹中，注意文件名只能由字母、数字和下划线组成</li><li>添加一个新的 ResId 变量，例如导出的文件名叫做 e2ec_sim.onnx ，那么可以加上一条新的语句：int e2ecId &#x3D; R.raw.e2ec_sim; </li><li>修改第 54 行的传入参数，将 tinyposePath 修改成 e2ecId</li><li>编译运行整个项目</li></ol><p>下面是我的运行结果：</p><p><img src="https://s2.loli.net/2024/03/12/jrlUzmiu9F58vZS.png" alt="7f108cf0-91dd-43ca-943c-b1ef133b04b7.png"></p><p>可以看到，最后会显示一个平均延时。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MNN GPU float16 使用原理</title>
    <link href="/2024/03/11/MNN_GPU_float16/"/>
    <url>/2024/03/11/MNN_GPU_float16/</url>
    
    <content type="html"><![CDATA[<p>我观察到 MNN 在使用 GPU OpenCL 时，会默认使用 float16 的格式，导致模型评测时时间不同，如图。因此查看了 MNN 的源码，发现了一些有趣的东西。</p><p><img src="https://s2.loli.net/2024/03/11/MPzmpRb4dDFEO1K.png" alt="Snipaste_2024-03-11_16-44-19.png"></p><p>MNN 使用 <code>MNN::BackendConfig::Precision_Low</code> 时，会根据 GPU 的实际情况判断是否使用 float16 的数据格式。代码随附。</p><p>当导出的模型可以使用 float32 或者 float16 保存，当权重转换到 GPU 上时，会转换格式，在代码的第19行到第22行。代码随附。</p><p>Pipeline 中保存的 tensor 指向的 opencl buffer 保存的还是 float16。但是 <code>OpenCL::onMapTensor</code> 和 <code>OpenCL::onUnmapTensor</code> 的实现保证了映射前后得到的是 float32。<code>OpenCLBackend::onAcquire</code> 给出了 tensor 中保存的 buffer 格式，其中调用了 <code>isSupportedFP16</code> 判断目前是否支持 float16，如果支持则使用 float16 的大小创建 buffer。</p><p><code>OpenCLBackend::onMapTensor</code> 给出了映射 gpu buffer 到 cpu 上的实现。调用 <code>onMapTensor</code> 时如果不支持 SVM，会创建一个新的 cpu 内存块（<code>svmPtr = allocMapTensorMemory</code>），可以执行任意操作。对这块内存操作完毕后，如果是以 <code>MAP_TENSOR_WRITE</code> 的形式创建的 tensor，会将内存重新写回到 gpu buffer 中（<code>onCopyBuffer(&amp;srcTensor, dstTensor)</code>），这个时候会执行一次数据格式转换，包括 float16 到 float32。这表示：<strong>每次只能 map 一个 gpu tensor，不能 map 两个</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MNN OpenCLBackend.cpp</span><br><span class="hljs-function">Backend::MemObj* <span class="hljs-title">OpenCLBackend::onAcquire</span><span class="hljs-params">(<span class="hljs-type">const</span> Tensor* nativeTensor, StorageType storageType)</span> </span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOG_VERBOSE</span><br>    <span class="hljs-built_in">MNN_PRINT</span>(<span class="hljs-string">&quot;Start OpenCLBackend::onAcquireBuffer !\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">auto</span> tensorShape = OpenCL::<span class="hljs-built_in">tensorShapeFormat</span>(nativeTensor);<br>    <span class="hljs-type">int</span> N = tensorShape.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> H = tensorShape.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> W = tensorShape.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> C = tensorShape.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOG_VERBOSE</span><br>    <span class="hljs-built_in">MNN_PRINT</span>(<span class="hljs-string">&quot;OpenCLBackend::onAcquireBuffer: NHWC:[%d, %d, %d, %d]\n&quot;</span>, N, H, W, C);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MNN_OPENCL_BUFFER_CLOSED</span><br>    <span class="hljs-keyword">if</span>(mOpenCLRuntime-&gt;<span class="hljs-built_in">getGpuMemType</span>() == BUFFER) &#123;<br>        <span class="hljs-type">size_t</span> size;<br>        <span class="hljs-keyword">if</span> (nativeTensor-&gt;<span class="hljs-built_in">dimensions</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> alignC = <span class="hljs-built_in">ROUND_UP</span>(C, <span class="hljs-number">8</span>);<br>            <span class="hljs-comment">// increment of height and width</span><br>            <span class="hljs-keyword">auto</span> hR = <span class="hljs-built_in">ROUND_UP</span>(H + <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) - H;<br>            <span class="hljs-keyword">auto</span> wR = <span class="hljs-built_in">ROUND_UP</span>(W + <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) - W;<br>            size = N * alignC * W * H;<br>            size = size + hR * W * <span class="hljs-number">4</span> + wR * <span class="hljs-number">4</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            size = nativeTensor-&gt;<span class="hljs-built_in">elementSize</span>();<br>            size = <span class="hljs-built_in">ROUND_UP</span>(size, <span class="hljs-number">4</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mOpenCLRuntime-&gt;<span class="hljs-built_in">isSupportedIntelSubgroup</span>()) &#123;<br>            <span class="hljs-type">int</span> cPack = TensorUtils::<span class="hljs-built_in">getTensorChannelPack</span>(nativeTensor);<br>            <span class="hljs-keyword">auto</span> pads  = TensorUtils::<span class="hljs-built_in">getDescribe</span>(nativeTensor)-&gt;mPads;<br>            <span class="hljs-type">size_t</span> imageWidth  = (<span class="hljs-type">size_t</span>) <span class="hljs-built_in">ROUND_UP</span>(<span class="hljs-built_in">UP_DIV</span>(C, cPack), <span class="hljs-number">2</span>) * <span class="hljs-built_in">ROUND_UP</span>(pads.left + W + pads.right, <span class="hljs-number">4</span>);<span class="hljs-comment">//C-round to 8,W-round to 4, for memory alloc</span><br>            <span class="hljs-type">size_t</span> imageHeight = (<span class="hljs-type">size_t</span>)N * H;<br>            size = imageWidth*imageHeight*cPack;<br>        &#125;<br>        cl_channel_type dataType = CL_FLOAT;<br>        <span class="hljs-comment">//when support and want fp16, use half datatype</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">isSupportedFP16</span>()) &#123;<br>            dataType = CL_HALF_FLOAT;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (storageType == DYNAMIC_SEPERATE) &#123;<br>            <span class="hljs-keyword">auto</span> buffer = mBufferPool-&gt;<span class="hljs-built_in">alloc</span>(size*<br>                          (dataType==CL_HALF_FLOAT?<span class="hljs-built_in">sizeof</span>(half_float::half):<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)), <span class="hljs-literal">true</span>);<br>            ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)buffer;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseBuffer</span>(buffer, mBufferPool.<span class="hljs-built_in">get</span>());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (storageType == DYNAMIC) &#123;<br>            <span class="hljs-keyword">auto</span> buffer = mBufferPool-&gt;<span class="hljs-built_in">alloc</span>(size*<br>                          (dataType==CL_HALF_FLOAT?<span class="hljs-built_in">sizeof</span>(half_float::half):<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>            ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)buffer;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseBuffer</span>(buffer, mBufferPool.<span class="hljs-built_in">get</span>());<br>        &#125;<br>        <span class="hljs-built_in">MNN_ASSERT</span>(storageType == STATIC);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MNN_LOW_MEMORY</span><br>        <span class="hljs-comment">// for weight quant model&#x27;s weight</span><br>        <span class="hljs-keyword">if</span> ((nativeTensor-&gt;<span class="hljs-built_in">getType</span>().code == halide_type_int) &amp;&amp;<br>            (nativeTensor-&gt;<span class="hljs-built_in">getType</span>().bits == <span class="hljs-number">8</span> || nativeTensor-&gt;<span class="hljs-built_in">getType</span>().bits == <span class="hljs-number">4</span>)) &#123;<br>            <span class="hljs-comment">// int8 quant</span><br>            <span class="hljs-type">size_t</span> alloc_size = size;<br>            <span class="hljs-keyword">if</span> (nativeTensor-&gt;<span class="hljs-built_in">getType</span>().bits == <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-comment">// int4 quant</span><br>                alloc_size = size / <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> buffer = mStaticBufferPool-&gt;<span class="hljs-built_in">alloc</span>(alloc_size);<br>            ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)buffer;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseBuffer</span>(buffer, mStaticBufferPool.<span class="hljs-built_in">get</span>());<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">auto</span> buffer = mStaticBufferPool-&gt;<span class="hljs-built_in">alloc</span>(size*<br>                     (dataType == CL_HALF_FLOAT ? <span class="hljs-built_in">sizeof</span>(half_float::half) : <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>        ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)buffer; <span class="hljs-comment">// fix</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseBuffer</span>(buffer, mStaticBufferPool.<span class="hljs-built_in">get</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* MNN_OPENCL_BUFFER_CLOSED */</span></span><br>    &#123;<br>        <span class="hljs-type">size_t</span> imageWidth  = (<span class="hljs-type">size_t</span>) (<span class="hljs-built_in">UP_DIV</span>(C, <span class="hljs-number">4</span>) * W);<span class="hljs-comment">//image mode only C pack to 4</span><br>        <span class="hljs-type">size_t</span> imageHeight = (<span class="hljs-type">size_t</span>)N * H;<br>        cl_channel_type dataType = CL_HALF_FLOAT;<br>        <span class="hljs-comment">//when user want high precision, use float datatype</span><br>        <span class="hljs-keyword">if</span> (mPrecision == BackendConfig::Precision_High) &#123;<br>            dataType = CL_FLOAT;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (storageType == DYNAMIC_SEPERATE) &#123;<br>            <span class="hljs-keyword">auto</span> image                               = mImagePool-&gt;<span class="hljs-built_in">alloc</span>(imageWidth, imageHeight, dataType, <span class="hljs-literal">true</span>);<br>            ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)image; <span class="hljs-comment">// fix</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseImage</span>(image, mImagePool.<span class="hljs-built_in">get</span>());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (storageType == DYNAMIC) &#123;<br>            <span class="hljs-keyword">auto</span> image                               = mImagePool-&gt;<span class="hljs-built_in">alloc</span>(imageWidth, imageHeight, dataType);<br>            ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)image; <span class="hljs-comment">// fix</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseImage</span>(image, mImagePool.<span class="hljs-built_in">get</span>());<br>        &#125;<br>        <span class="hljs-built_in">MNN_ASSERT</span>(storageType == STATIC);<br>        <span class="hljs-keyword">auto</span> image                               = mStaticImagePool-&gt;<span class="hljs-built_in">alloc</span>(imageWidth, imageHeight, dataType);<br>        ((Tensor*)nativeTensor)-&gt;<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)image; <span class="hljs-comment">// fix</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CLMemReleaseImage</span>(image, mStaticImagePool.<span class="hljs-built_in">get</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">OpenCLBackend::onMapTensor</span><span class="hljs-params">(Tensor::MapType mtype, Tensor::DimensionType dtype, <span class="hljs-type">const</span> Tensor* srcTensor)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> needSize = srcTensor-&gt;<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">clearRecord</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MNN_OPENCL_SVM_ENABLE</span><br>    <span class="hljs-keyword">auto</span> svm_cap_ = mOpenCLRuntime-&gt;<span class="hljs-built_in">getSvmCapabilities</span>();<br>    <span class="hljs-type">bool</span> use_svm = (svm_cap_ &amp; CL_DEVICE_SVM_FINE_GRAIN_BUFFER);<span class="hljs-comment">//support fine grain svm</span><br>    use_svm |= ((svm_cap_ &amp; CL_DEVICE_SVM_COARSE_GRAIN_BUFFER) &amp;&amp; mOpenCLRuntime-&gt;<span class="hljs-built_in">getGpuType</span>() == ADRENO);<span class="hljs-comment">//support coarse grain svm and adreno gpu</span><br><br>    mUseSvm = (mOpenCLRuntime-&gt;<span class="hljs-built_in">getCLVersion</span>() &gt; <span class="hljs-number">1.99f</span> &amp;&amp; use_svm);<br>    <span class="hljs-keyword">if</span>(mUseSvm) &#123;<span class="hljs-comment">// CL version beyond 2.0 &amp; support svm</span><br>        svmPtr = <span class="hljs-built_in">allocMapTensorMemory</span>(needSize, <span class="hljs-literal">true</span>, svm_cap_);<br><br>        <span class="hljs-keyword">if</span>(mtype == Tensor::MAP_TENSOR_READ) &#123;<br>            <span class="hljs-comment">//tmpTensor alloc</span><br>            <span class="hljs-function">MNN::Tensor <span class="hljs-title">tmpTensor</span><span class="hljs-params">(srcTensor, dtype, <span class="hljs-literal">false</span>)</span></span>;<br>            tmpTensor.<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)svmPtr;<br><br>            <span class="hljs-comment">//Convert format</span><br>            MNN_DATA_FORMAT format_type = MNN_DATA_FORMAT_NCHW;<br>            <span class="hljs-keyword">if</span>(dtype == MNN::Tensor::TENSORFLOW) &#123;<br>                format_type = MNN_DATA_FORMAT_NHWC;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dtype == MNN::Tensor::CAFFE_C4) &#123;<br>                format_type = MNN_DATA_FORMAT_NC4HW4;<br>            &#125;<br>            mCLRuntime-&gt;<span class="hljs-built_in">convertFromDevice</span>(srcTensor, &amp;tmpTensor, format_type, <span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(svm_cap_ &amp; CL_DEVICE_SVM_FINE_GRAIN_BUFFER) &#123;<br>            <span class="hljs-comment">//Make sure command finished</span><br>            mOpenCLRuntime-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">finish</span>();<br>            <span class="hljs-keyword">return</span> svmPtr;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> map_flag = CL_MAP_WRITE;<br>        <span class="hljs-keyword">if</span>(mtype == Tensor::MAP_TENSOR_READ) &#123;<br>            map_flag = CL_MAP_READ;<br>        &#125;<br><br>        cl_int res = <span class="hljs-built_in">clEnqueueSVMMap</span>(mOpenCLRuntime-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">get</span>(), <span class="hljs-literal">true</span>, map_flag, svmPtr, needSize, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br><br>        <span class="hljs-built_in">MNN_CHECK_CL_SUCCESS</span>(res, <span class="hljs-string">&quot;svm_map&quot;</span>)<br>        <span class="hljs-keyword">return</span> svmPtr;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    Not Support Svm, Use onopyBuffer</span><br><span class="hljs-comment">     */</span><br>    svmPtr = <span class="hljs-built_in">allocMapTensorMemory</span>(needSize, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">if</span>(mtype == Tensor::MAP_TENSOR_READ) &#123;<br>        <span class="hljs-comment">//tmpTensor alloc</span><br>        <span class="hljs-function">MNN::Tensor <span class="hljs-title">tmpTensor</span><span class="hljs-params">(srcTensor, dtype, <span class="hljs-literal">false</span>)</span></span>;<br>        tmpTensor.<span class="hljs-built_in">buffer</span>().host = (<span class="hljs-type">uint8_t</span> *)svmPtr;<br><br>        <span class="hljs-comment">//use onCopyBuffer</span><br>        <span class="hljs-built_in">onCopyBuffer</span>(srcTensor, &amp;tmpTensor);<br>    &#125;<br>    <span class="hljs-keyword">return</span> svmPtr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OpenCLBackend::onUnmapTensor</span><span class="hljs-params">(Tensor::MapType mtype, Tensor::DimensionType dtype, <span class="hljs-type">const</span> Tensor* dstTensor, <span class="hljs-type">void</span>* mapPtr)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MNN_OPENCL_SVM_ENABLE</span><br>    <span class="hljs-keyword">auto</span> svm_cap_ = mOpenCLRuntime-&gt;<span class="hljs-built_in">getSvmCapabilities</span>();<br>    <span class="hljs-keyword">if</span>(mUseSvm) &#123;<span class="hljs-comment">// CL version beyond 2.0 &amp; support svm</span><br><br>        <span class="hljs-comment">//If COARSE_SVM, Unmap first</span><br>        <span class="hljs-keyword">if</span>(!(svm_cap_ &amp; CL_DEVICE_SVM_FINE_GRAIN_BUFFER)) &#123;<br>            cl_int res = <span class="hljs-built_in">clEnqueueSVMUnmap</span>(mOpenCLRuntime-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">get</span>(), svmPtr, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">MNN_CHECK_CL_SUCCESS</span>(res, <span class="hljs-string">&quot;svm_unmap&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(mtype == Tensor::MAP_TENSOR_WRITE) &#123;<br>            <span class="hljs-comment">//interTensor alloc</span><br>            <span class="hljs-function">MNN::Tensor <span class="hljs-title">interTensor</span><span class="hljs-params">(dstTensor, dtype, <span class="hljs-literal">false</span>)</span></span>;<br>            interTensor.<span class="hljs-built_in">buffer</span>().device = (<span class="hljs-type">uint64_t</span>)svmPtr;<br><br>            <span class="hljs-comment">//Convert format</span><br>            MNN_DATA_FORMAT format_type = MNN_DATA_FORMAT_NCHW;<br>            <span class="hljs-keyword">if</span>(dtype == MNN::Tensor::TENSORFLOW) &#123;<br>                format_type = MNN_DATA_FORMAT_NHWC;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dtype == MNN::Tensor::CAFFE_C4) &#123;<br>                format_type = MNN_DATA_FORMAT_NC4HW4;<br>            &#125;<br>            mCLRuntime-&gt;<span class="hljs-built_in">convertToDevice</span>(&amp;interTensor, dstTensor, format_type, <span class="hljs-literal">true</span>);<br>        &#125;<br>        mOpenCLRuntime-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">finish</span>();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    Not Support Svm, Use onopyBuffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span>(mtype == Tensor::MAP_TENSOR_WRITE) &#123;<br>        <span class="hljs-comment">//srcTensor alloc</span><br>        <span class="hljs-function">MNN::Tensor <span class="hljs-title">srcTensor</span><span class="hljs-params">(dstTensor, dtype, <span class="hljs-literal">false</span>)</span></span>;<br>        srcTensor.<span class="hljs-built_in">buffer</span>().host = (<span class="hljs-type">uint8_t</span> *)svmPtr;<br><br>        <span class="hljs-comment">//use onCopyBuffer</span><br>        <span class="hljs-built_in">onCopyBuffer</span>(&amp;srcTensor, dstTensor);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><span class="hljs-comment">// MNN ConvBufExecution.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConvBufExecution::setConv1x1WeightBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> packCout, <span class="hljs-type">int</span> packCin, <span class="hljs-type">const</span> <span class="hljs-type">float</span>* filterDataPtr)</span> </span>&#123;<br>    cl_int res;<br>    <span class="hljs-function">std::shared_ptr&lt;Tensor&gt; <span class="hljs-title">filterBuffer</span><span class="hljs-params">(Tensor::createDevice&lt;<span class="hljs-type">float</span>&gt;(&#123;ROUND_UP(mOutputChannel, <span class="hljs-number">8</span>)<span class="hljs-comment">/*Cout pack set to max 8*/</span>, ROUND_UP(mInputChannel, packCin), mKernelWidth, mKernelHeight&#125;))</span></span>;<br>    <br>    <span class="hljs-type">int</span> buffer_size = filterBuffer-&gt;<span class="hljs-built_in">elementSize</span>();<br>    <span class="hljs-keyword">if</span>(mOpenCLBackend-&gt;<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">isSupportedFP16</span>()) &#123;<br>        buffer_size *= <span class="hljs-built_in">sizeof</span>(half_float::half);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        buffer_size *= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>    &#125;<br>    mKernelBuffer.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> cl::<span class="hljs-built_in">Buffer</span>(mOpenCLBackend-&gt;<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">context</span>(), CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR, buffer_size));<br>    <span class="hljs-keyword">auto</span> kernelBufferPtr = mOpenCLBackend-&gt;<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">enqueueMapBuffer</span>(*(mKernelBuffer.<span class="hljs-built_in">get</span>()), <span class="hljs-literal">true</span>, CL_MAP_WRITE, <span class="hljs-number">0</span>, buffer_size, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, &amp;res);<br>    <span class="hljs-keyword">if</span>(kernelBufferPtr != <span class="hljs-literal">nullptr</span> &amp;&amp; res == CL_SUCCESS)&#123;<br>        ::<span class="hljs-built_in">memset</span>(kernelBufferPtr, <span class="hljs-number">0</span>, buffer_size);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> o = <span class="hljs-number">0</span>; o &lt; mOutputChannel; o++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; mInputChannel; i++)&#123;<br>                <span class="hljs-type">int</span> bufferIdx = (o/packCout) * <span class="hljs-built_in">ROUND_UP</span>(mInputChannel, packCin)*packCout + (i/packCin)*packCin*packCout + (o%packCout)*packCin + (i%packCin);<span class="hljs-comment">//(Co/packCout, Ci/packCin, packCout, packCin)</span><br>                <span class="hljs-type">int</span> filterIdx = o*mInputChannel + i;<br>                <span class="hljs-keyword">if</span>(mOpenCLBackend-&gt;<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">isSupportedFP16</span>())&#123;<br>                    ((half_float::half*)kernelBufferPtr)[bufferIdx] = (half_float::half)(filterDataPtr[filterIdx]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ((<span class="hljs-type">float</span>*)kernelBufferPtr)[bufferIdx] = (<span class="hljs-type">float</span>)(filterDataPtr[filterIdx]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">MNN_ERROR</span>(<span class="hljs-string">&quot;Map error ptrCL == nullptr \n&quot;</span>);<br>        <span class="hljs-built_in">MNN_ASSERT</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    mOpenCLBackend-&gt;<span class="hljs-built_in">getOpenCLRuntime</span>()-&gt;<span class="hljs-built_in">commandQueue</span>().<span class="hljs-built_in">enqueueUnmapMemObject</span>(*(mKernelBuffer.<span class="hljs-built_in">get</span>()), kernelBufferPtr);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MNN OpenCLRuntime.cpp</span><br>cl_device_fp_config fpConfig;<br><span class="hljs-keyword">auto</span> success = mFirstGPUDevicePtr-&gt;<span class="hljs-built_in">getInfo</span>(CL_DEVICE_HALF_FP_CONFIG, &amp;fpConfig);<br>mIsDeviceSupportedFP16     = CL_SUCCESS == success &amp;&amp; fpConfig &gt; <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//set gpu mode, tuning level and memory object</span><br><span class="hljs-built_in">setGpuMode</span>(cl_mode);<br><br><span class="hljs-keyword">if</span>(mMemType == AUTO) &#123;<br>    <span class="hljs-keyword">if</span>(mGpuType == MALI || mGpuType == INTEL) &#123;<br>        mMemType = BUFFER;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mMemType = IMAGE;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> permitFloat16 = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (precision == BackendConfig::Precision_Low || (mMemType == BUFFER &amp;&amp; precision == BackendConfig::Precision_Normal)) &#123;<span class="hljs-comment">//buffer mode not support Normal Precision yet</span><br>    permitFloat16 = <span class="hljs-literal">true</span>;<br>&#125;<br>mIsSupportedFP16 = mIsDeviceSupportedFP16 &amp;&amp; permitFloat16;<br><span class="hljs-built_in">MNN_PRINT</span>(<span class="hljs-string">&quot;opencl support fp16: %d, device support fp16: %d, permit fp16: %d\n&quot;</span>, mIsSupportedFP16, mIsDeviceSupportedFP16, permitFloat16);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/11/hello-world/"/>
    <url>/2024/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
